<div class="docs-markdown"><p translation-result="on">这个 <code>scrolling</code> 包为那些要对滚动事件做出反应的指令提供了辅助设施。</p><p translation-origin="off">The <code>scrolling</code> package provides helpers for directives that react to scroll events.</p>


        <h3 id="cdkscrollable-and-scrolldispatcher" class="docs-header-link" translation-result="on">
          <span header-link="cdkscrollable（可滚动的）-和-scrolldispatcher（滚动派发器）"></span>
          cdkScrollable（可滚动的） 和 ScrollDispatcher（滚动派发器）
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="cdkscrollable-and-scrolldispatcher"></span>
          cdkScrollable and ScrollDispatcher
        </h3>
      
        
      <p translation-result="on"><code>cdkScrollable</code> 指令和 <code>ScrollDispatcher</code> 服务一起让组件能对其任意上级滚动容器中的滚动事件做出反应。</p><p translation-origin="off">The <code>cdkScrollable</code> directive and the <code>ScrollDispatcher</code> service together allow components to
react to scrolling in any of its ancestor scrolling containers.</p>

<p translation-result="on">要把 <code>cdkScrollable</code> 指令应用在任何充当滚动容器的元素上。这会把该元素标记为 <code>Scrollable</code> 并把它注册到 <code>ScrollDispatcher</code> 中。这时派发器允许组件分享这些事件监听器和应用中所有可滚动容器的知识。</p><p translation-origin="off">The <code>cdkScrollable</code> directive should be applied to any element that acts as a scrolling container.
This marks the element as a <code>Scrollable</code> and registers it with the <code>ScrollDispatcher</code>. The
dispatcher, then, allows components to share both event listeners and knowledge of all of the
scrollable containers in the application.</p>


        <h3 id="viewportruler" class="docs-header-link" translation-result="on">
          <span header-link="viewportruler（视口标尺）"></span>
          ViewportRuler（视口标尺）
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="viewportruler"></span>
          ViewportRuler
        </h3>
      
        
      <p translation-result="on"><code>ViewportRuler</code> 是一种可注入的服务，用于衡量浏览器视口的范围。</p><p translation-origin="off">The <code>ViewportRuler</code> is a service that can be injected and used to measure the bounds of the browser
viewport.</p>


        <h3 id="virtual-scrolling" class="docs-header-link" translation-result="on">
          <span header-link="虚拟滚动"></span>
          虚拟滚动
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="virtual-scrolling"></span>
          Virtual scrolling
        </h3>
      
        
      <p translation-result="on"><code>&lt;cdk-virtual-scroll-viewport&gt;</code> 通过仅仅渲染那些屏幕上可见的条目，来高效的显示大型列表。在任何浏览器中加载数百个元素都会很慢，虚拟滚动可以用一种高效的方式模拟渲染全部条目，方法是让容器元素的高度与要渲染的元素的总高度相同，然后才渲染视图中的条目。虚拟滚动不同于无限滚动这样的策略，它会渲染一定数量的元素，然后在你点击两端时渲染剩下的元素。</p><p translation-origin="off">The <code>&lt;cdk-virtual-scroll-viewport&gt;</code> displays large lists of elements performantly by only
rendering the items that fit on-screen. Loading hundreds of elements can be slow in any browser;
virtual scrolling enables a performant way to simulate all items being rendered by making the
height of the container element the same as the height of total number of elements to be rendered,
and then only rendering the items in view. Virtual scrolling is different from strategies like
infinite scroll where it renders a set amount of elements and then when you hit the end renders the
rest.</p>


        <h4 id="creating-items-in-the-viewport" class="docs-header-link" translation-result="on">
          <span header-link="在视口中创建条目"></span>
          在视口中创建条目
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="creating-items-in-the-viewport"></span>
          Creating items in the viewport
        </h4>
      
        
      <p translation-result="on"><code>*cdkVirtualFor</code> 替换了 <code>&lt;cdk-virtual-scroll-viewport&gt;</code> 中的 <a href="https://angular.cn/api/common/NgForOf"><code>*ngFor</code></a>，它支持与 <a href="https://angular.cn/api/common/NgForOf"><code>*ngFor</code></a> 完全相同的 API。最简单的用法就是指定条目列表（注意，必须在视口中设置 <code>itemSize</code> 属性）：</p><p translation-origin="off"><code>*cdkVirtualFor</code> replaces <code>*ngFor</code> inside of a <code>&lt;cdk-virtual-scroll-viewport&gt;</code>, supporting the exact
same API as <a href="https://angular.io/api/common/NgForOf"><code>*ngFor</code></a>. The simplest usage just specifies the
list of items (note that the <code>itemSize</code> property on the viewport must be set):</p>

<div material-docs-example="cdk-virtual-scroll-overview"></div>

<p translation-result="on"><code>*cdkVirtualFor</code> 让模板中可以使用这些上下文变量：</p><p translation-origin="off"><code>*cdkVirtualFor</code> makes the following context variables available to the template:</p>

<table>
<thead>
<tr>
<th><nt-wrapper translation-result="on">上下文变量</nt-wrapper><nt-wrapper translation-origin="off">Context variable</nt-wrapper></th>
<th><nt-wrapper translation-result="on">说明</nt-wrapper><nt-wrapper translation-origin="off">Description</nt-wrapper></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>index</code></td>
<td><nt-wrapper translation-result="on">该条目在数据源中的索引。</nt-wrapper><nt-wrapper translation-origin="off">The index of the item in the data source.</nt-wrapper></td>
</tr>

<tr>
<td><code>count</code></td>
<td><nt-wrapper translation-result="on">数据源中的条目总数。</nt-wrapper><nt-wrapper translation-origin="off">The total number of items in the data source.</nt-wrapper></td>
</tr>

<tr>
<td><code>first</code></td>
<td><nt-wrapper translation-result="on">这是否是数据源中的第一个条目。</nt-wrapper><nt-wrapper translation-origin="off">Whether this is the first item in the data source.</nt-wrapper></td>
</tr>

<tr>
<td><code>last</code></td>
<td><nt-wrapper translation-result="on">这是否是数据源中的最后一个条目。</nt-wrapper><nt-wrapper translation-origin="off">Whether this is the last item in the data source.</nt-wrapper></td>
</tr>

<tr>
<td><code>even</code></td>
<td><nt-wrapper translation-result="on">该 <code>index</code> 是否为偶数。</nt-wrapper><nt-wrapper translation-origin="off">Whether the <code>index</code> is even.</nt-wrapper></td>
</tr>

<tr>
<td><code>odd</code></td>
<td><nt-wrapper translation-result="on">该 <code>index</code> 是否为奇数。</nt-wrapper><nt-wrapper translation-origin="off">Whether the <code>index</code> is odd.</nt-wrapper></td>
</tr>

</tbody></table>
<p translation-result="on">所有这些都是本条目在数据源中的索引，而不是在要渲染的那部分数据的索引。</p><p translation-origin="off">All of these apply to the index of the item in the data source, not the index in the rendered
portion of the data.</p>

<div material-docs-example="cdk-virtual-scroll-context"></div>

<p translation-result="on">像 <code>*ngFor</code> 的 <code>trackBy</code> 一样，这里也可以指定 <code>trackBy</code> 函数，工作方式也都一样。传给这个 <code>trackBy</code> 的 <code>index</code> 是在数据源中的索引，而不是在要渲染的这部分数据中的索引。</p><p translation-origin="off">A <code>trackBy</code> function can be specified and works the same as the <code>*ngFor</code> <code>trackBy</code>. The <code>index</code>
passed to the tracking function will be the index in the data source, not the index in the rendered
portion.</p>


        <h5 id="view-recycling" class="docs-header-link" translation-result="on">
          <span header-link="视图回收"></span>
          视图回收
        </h5><h5 class="docs-header-link" translation-origin="off">
          <span header-link="view-recycling"></span>
          View recycling
        </h5>
      
        
      <p translation-result="on">为了提高渲染性能，<code>*cdkVirtualFor</code> 会缓存那些曾经创建过但不再需要的视图。当要创建一个新视图时，会转而复用一个已缓存的视图。可以通过 <code>templateCacheSize</code> 属性来调整视图缓存的大小。把这个大小设置为 <code>0</code> 会禁用缓存。如果你的模板在内存方面很昂贵，你可能会希望减小这个数字，以免在模板缓存上花费太多内存。</p><p translation-origin="off">To improve rendering performance, <code>*cdkVirtualFor</code> caches previously created views after
they are no longer needed. When a new view would normally be created, a cached view
is reused instead. The size of the view cache can be adjusted via the <code>templateCacheSize</code>
property; setting this size to <code>0</code> disables caching. If your templates are expensive in terms of
memory you may wish to reduce this number to avoid spending too much memory on the template cache.</p>

<div material-docs-example="cdk-virtual-scroll-template-cache"></div>


        <h5 id="specifying-data" class="docs-header-link" translation-result="on">
          <span header-link="指定数据"></span>
          指定数据
        </h5><h5 class="docs-header-link" translation-origin="off">
          <span header-link="specifying-data"></span>
          Specifying data
        </h5>
      
        
      <p translation-result="on"><code>*cdkVirtualFor</code> 接受来自 <code>Array</code>、<code>Observable&lt;Array&gt;</code> 或 <code>DataSource</code> 的数据。虚拟滚动的 <code>DataSource</code> 与表格和树组件所用的 <code>DataSource</code> 是同一个。<code>DataSource</code> 只是一个抽象类，它有两个方法：<code>connect</code> 和 <code>disconnect</code>。虚拟滚动视口将调用这个 <code>connect</code> 方法，以接收一个流，这个流会发出要渲染的数据数组。当 viewport 被销毁时，视口会调用 <code>disconnect</code>，这可能是清理连接过程中注册进来的所有订阅的最佳时机。</p><p translation-origin="off"><code>*cdkVirtualFor</code> accepts data from an <code>Array</code>, <code>Observable&lt;Array&gt;</code>, or <code>DataSource</code>. The
<code>DataSource</code> for the virtual scroll is the same one used by the table and tree components. A
<code>DataSource</code> is simply an abstract class that has two methods: <code>connect</code> and <code>disconnect</code>. The
<code>connect</code> method will be called by the virtual scroll viewport to receive a stream that emits the
data array that should be rendered. The viewport will call <code>disconnect</code> when the viewport is
destroyed, which may be the right time to clean up any subscriptions that were registered during the
connect process.</p>

<div material-docs-example="cdk-virtual-scroll-data-source"></div>


        <h4 id="scrolling-over-fixed-size-items" class="docs-header-link" translation-result="on">
          <span header-link="滚动那些固定大小的条目"></span>
          滚动那些固定大小的条目
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="scrolling-over-fixed-size-items"></span>
          Scrolling over fixed size items
        </h4>
      
        
      <p translation-result="on">当所有条目都是固定大小时，你可以使用 <code>FixedSizeVirtualScrollStrategy</code>。可以用 <code>itemSize</code> 指令轻松地将它添加到视口中。这种约束的优点是它可以提供更好的性能，因为在渲染条目时不需要进行测量。</p><p translation-origin="off">When all items are the same fixed size, you can use the <code>FixedSizeVirtualScrollStrategy</code>. This can
be easily added to your viewport using the <code>itemSize</code> directive. The advantage of this constraint is
that it allows for better performance, since items do not need to be measured as they are rendered. </p>

<p translation-result="on">固定大小的策略也支持设置一些缓冲区参数，用来决定渲染多少额外内容，也就是视口可见内容之外的部分。第一个参数是 <code>minBufferPx</code>。<code>minBufferPx</code> 是视口必须渲染的最小内容缓冲区数量（以像素为单位）。如果视口检测到要缓冲的内容小于这个数量（未填满），就会立即渲染更多内容。第二个参数是 <code>maxBufferPx</code>。它会告诉视口当检测到需要更多缓冲区的时候要渲染多少个备用缓冲区空间。</p><p translation-origin="off">The fixed size strategy also supports setting a couple of buffer parameters that determine how much
extra content is rendered beyond what is visible in the viewport. The first of these parameters is
<code>minBufferPx</code>. The <code>minBufferPx</code> is the minimum amount of content buffer (in pixels) that the
viewport must render. If the viewport ever detects that there is less buffered content it will
immediately render more. The second buffer parameter is <code>maxBufferPx</code>. This tells the viewport how 
much buffer space to render back up to when it detects that more buffer is required.</p>

<p translation-result="on">这两个缓冲区参数的作用可以用一个例子来说明。假设我们有以下参数：<code>itemSize = 50</code>、<code>minBufferPx = 100</code>、<code>maxBufferPx = 250</code>。当用户滚动浏览内容时，视口就会检测到只剩下 <code>90px</code> 的缓冲区。由于它小于 <code>minBufferPx</code>，所以视口必须渲染更多缓冲区。它必须渲染足够数量的缓冲区，直到其大于等于 <code>maxBufferPx</code>。在这种情况下，它渲染了 4 个条目（额外的 <code>200px</code>），使缓冲区总大小达到 <code>290px</code>，略高于 <code>maxBufferPx</code>。</p><p translation-origin="off">The interaction of these two buffer parameters can be best illustrated with an example. Supposed 
that we have the following parameters: <code>itemSize = 50</code>, <code>minBufferPx = 100</code>, <code>maxBufferPx = 250</code>. As
the user is scrolling through the content the viewport detects that there is only <code>90px</code> of buffer
remaining. Since this is below <code>minBufferPx</code> the viewport must render more buffer. It must render at
least enough buffer to get back to <code>maxBufferPx</code>. In this case, it renders 4 items (an additional
<code>200px</code>) to bring the total buffer size to <code>290px</code>, back above <code>maxBufferPx</code>.</p>

<div material-docs-example="cdk-virtual-scroll-fixed-buffer"></div>

<p translation-result="on">其他虚拟滚动策略可以通过扩展 <code>VirtualScrollStrategy</code> 来实现。目前正在 <code>@angular/cdk-experimental</code> 开发一种适用于不同大小元素的自动调整策略，但还没有准备好用于生产环境。</p><p translation-origin="off">Other virtual scrolling strategies can be implemented by extending <code>VirtualScrollStrategy</code>. An
autosize strategy that works on elements of differing sizes is currently being developed in
<code>@angular/cdk-experimental</code>, but it is not ready for production use yet. </p>


        <h3 id="viewport-orientation" class="docs-header-link" translation-result="on">
          <span header-link="视口方向"></span>
          视口方向
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="viewport-orientation"></span>
          Viewport orientation
        </h3>
      
        
      <p translation-result="on">虚拟滚动视口默认为垂直方向，也可以设置为 <code>orientation="horizontal"</code>。在改变方向时，要确保该条目是用 CSS 进行水平布局的。要做到这一点，你可能希望把 <code>.cdk-virtual-scroll-content-wrapper</code> 类作为 CSS 的目标，它是包含待渲染内容的包装元素。</p><p translation-origin="off">The virtual-scroll viewport defaults to a vertical orientation, but can also be set to
<code>orientation="horizontal"</code>. When changing the orientation, ensure that the item are laid
out horizontally via CSS. To do this you may want to target CSS at
<code>.cdk-virtual-scroll-content-wrapper</code> which is the wrapper element that contains the rendered
content.</p>

<div material-docs-example="cdk-virtual-scroll-horizontal"></div>


        <h3 id="elements-with-parent-tag-requirements" class="docs-header-link" translation-result="on">
          <span header-link="那些对父标签有特定要求的元素"></span>
          那些对父标签有特定要求的元素
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="elements-with-parent-tag-requirements"></span>
          Elements with parent tag requirements
        </h3>
      
        
      <p translation-result="on">某些 HTML 元素（如 <code>&lt;tr&gt;</code> 和 <code>&lt;li&gt;</code>）对它们所在的父元素种类有一些限制。要想对这些类型的元素进行虚拟滚动操作，就要把它们放在合适的父元素中，然后把它们共同包装在 <code>cdk-virtual-scroll-viewport</code> 中。注意，父组件中不要引入额外的空白区（比如通过 <code>margin</code> 或 <code>padding</code>），因为这样会干扰滚动。</p><p translation-origin="off">Some HTML elements such as <code>&lt;tr&gt;</code> and <code>&lt;li&gt;</code> have limitations on the kinds of parent elements they
can be placed inside. To enable virtual scrolling over these type of elements, place the elements in
their proper parent, and then wrap the whole thing in a <code>cdk-virtual-scroll-viewport</code>. Be careful
that the parent does not introduce additional space (e.g. via <code>margin</code> or <code>padding</code>) as it will
interfere with the scrolling.</p>

<div material-docs-example="cdk-virtual-scroll-dl"></div>


        <h3 id="scrolling-strategies" class="docs-header-link" translation-result="on">
          <span header-link="滚动策略"></span>
          滚动策略
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="scrolling-strategies"></span>
          Scrolling strategies
        </h3>
      
        
      <p translation-result="on">为了确定整个内容的大小以及它在任何时刻需要实际渲染的内容，视口依赖于所提供的一个 <code>VirtualScrollStrategy</code>。提供它的最简单方式是在视口上使用 <code>itemSize</code> 指令（例如 <code>&lt;cdk-virtual-scroll-viewport itemSize="50"&gt;</code>）。但是，也可以通过创建一个实现 <code>VirtualScrollStrategy</code> 接口的类来提供自定义策略，并在包含此视口的组件上把它提供为 <code>VIRTUAL_SCROLL_STRATEGY</code>。</p><p translation-origin="off">In order to determine how large the overall content is and what portion of it actually needs to be
rendered at any given time the viewport relies on a <code>VirtualScrollStrategy</code> being provided. The
simplest way to provide it is to use the <code>itemSize</code> directive on the viewport
(e.g. <code>&lt;cdk-virtual-scroll-viewport itemSize="50"&gt;</code>). However it is also possible to provide a 
custom strategy by creating a class that implements the <code>VirtualScrollStrategy</code> interface and
providing it as the <code>VIRTUAL_SCROLL_STRATEGY</code> on the component containing your viewport.</p>

<div material-docs-example="cdk-virtual-scroll-custom-strategy"></div>


        <h3 id="append-only-mode" class="docs-header-link" translation-result="on">
          <span header-link="仅追加模式"></span>
          仅追加模式
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="append-only-mode"></span>
          Append only mode
        </h3>
      
        
      <p translation-result="on">渲染非平凡条目的虚拟滚动视口可能会发现，在用户滚动时简单地附加到列表而用不删除已渲染的视图会更高效。 <code>appendOnly</code> 输入确保已渲染的视图在滚动出视图后仍保留在 DOM 中。</p><p translation-origin="off">Virtual scroll viewports that render nontrivial items may find it more performant to simply append
to the list as the user scrolls without removing rendered views. The <code>appendOnly</code> input ensures
views that are already rendered persist in the DOM after they scroll out of view.</p>

<div material-docs-example="cdk-virtual-scroll-append-only"></div>


        <h3 id="separate-viewport-and-scrolling-element" class="docs-header-link" translation-result="on">
          <span header-link="单独的视口和滚动元素"></span>
          单独的视口和滚动元素
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="separate-viewport-and-scrolling-element"></span>
          Separate viewport and scrolling element
        </h3>
      
        
      <p translation-result="on">默认情况下，虚拟滚动视口本身就会充当滚动元素。但是，在某些情况下，你可能希望让此视口滚动其父元素之一。例如，如果你想要一些非虚拟化内容，用户可以在虚拟化内容之前或之后滚动浏览。</p><p translation-origin="off">The virtual scroll viewport itself acts as the scrolling element by default. However, there may be
some cases where you want to have the viewport scroll one of its parent elements. For example,
if you want to have some non-virtualized content that the user can scroll through before or after
the virtualized content.</p>

<p translation-result="on">要将 <code>cdk-vritual-scroll-viewport</code> 配置为使用其父元素之一作为滚动元素，请把 <code>cdkVirtualScrollingElement</code> 应用于那个父元素。</p><p translation-origin="off">To configure a <code>cdk-virtual-scroll-viewport</code> to use one of its parent elements as the scrolling
element, apply <code>cdkVirtualScrollingElement</code> to the scrolling parent element.</p>

<div material-docs-example="cdk-virtual-scroll-parent-scrolling"></div>

<p translation-result="on">另一个常见的场景是使用 <code>window</code> 本身作为滚动元素。这通常是移动设备上更好的用户体验，因为它允许浏览器 Chrome 地址栏滚动出去。要将 <code>window</code> 用作滚动元素，请将 <code>scrollWindow</code> 属性添加到 <code>cdk-virtual-scroll-viewport</code> 。</p><p translation-origin="off">Another common scenario is using the window itself as the scrolling element. This often a better
user experience on mobile devices, as it allows the browser chrome to scroll away. To use the
window as the scrolling element, add the <code>scrollWindow</code> attribute to the 
<code>cdk-virtual-scroll-viewport</code>.</p>

<div material-docs-example="cdk-virtual-scroll-window-scrolling"></div>
</div>