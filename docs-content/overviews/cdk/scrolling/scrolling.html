<div class="docs-markdown"><p data-ng_translator_product="100" data-ng_translator_ref_id="8k0ha9gq4tfgb6ul60x0boq3x">这个 <code>scrolling</code> 包为那些要对滚动事件做出反应的指令提供了辅助设施。</p>

        <h3 id="cdkscrollable-and-scrolldispatcher" class="docs-header-link" data-ng_translator_product="100" data-ng_translator_ref_id="7rk9tpj2du8qylgpsyxectlqb">cdkScrollable 与 ScrollDispatcher</h3>
      <p data-ng_translator_product="100" data-ng_translator_ref_id="eluyls3ympvph9ahlx0vjbxtz"><code>cdkScrollable</code> 指令和 <code>ScrollDispatcher</code> 服务一起让组件能对其任意上级滚动容器中的滚动事件做出反应。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="1t34h90xspe18t4z53udn0qk4">要把 <code>cdkScrollable</code> 指令应用在任何充当滚动容器的元素上。这会把该元素标记为 <code>Scrollable</code> 并把它注册到 <code>ScrollDispatcher</code> 中。这时派发器允许组件分享这些事件监听器和应用中所有可滚动容器的知识。</p>

        <h3 id="viewportruler" class="docs-header-link">
          
          ViewportRuler
        </h3>
      <p data-ng_translator_product="100" data-ng_translator_ref_id="csa2pyclhyzofvpoxu50lgkmm"><code>ViewportRuler</code> 是一种可注入的服务，用于衡量浏览器视口的范围。</p>

        <h3 id="virtual-scrolling" class="docs-header-link" data-ng_translator_product="100" data-ng_translator_ref_id="2zoksq9mr734g8lwpgr2v2511">虚拟滚动</h3>
      <p data-ng_translator_product="100" data-ng_translator_ref_id="npt1fpqygaoqait1blb5sewp"><code>&lt;cdk-virtual-scroll-viewport&gt;</code> 通过仅仅渲染那些屏幕上可见的条目，来高效的显示大型列表。在任何浏览器中加载数百个元素都会很慢，虚拟滚动可以用一种高效的方式模拟渲染全部条目，方法是让容器元素的高度与要渲染的元素的总高度相同，然后才渲染视图中的条目。虚拟滚动不同于无限滚动这样的策略，它会渲染一定数量的元素，然后在你点击两端时渲染剩下的元素。</p>

        <h4 id="creating-items-in-the-viewport" class="docs-header-link" data-ng_translator_product="100" data-ng_translator_ref_id="bl3ou0vyu5ijwzj4or8ny0shi">在视口中创建条目</h4>
      <p data-ng_translator_product="100" data-ng_translator_ref_id="aia3ggqts35fy3pmci3cggj8m"><code>*cdkVirtualFor</code> 替换了 <code>&lt;cdk-virtual-scroll-viewport&gt;</code> 中的 <a href="https://angular.cn/api/common/NgForOf"><code>*ngFor</code></a>，它支持与 <a href="https://angular.cn/api/common/NgForOf"><code>*ngFor</code></a> 完全相同的 API。最简单的用法就是指定条目列表（注意，必须在视口中设置 <code>itemSize</code> 属性）：</p>
<div material-docs-example="cdk-virtual-scroll-overview"></div>

<p data-ng_translator_product="100" data-ng_translator_ref_id="1janlx34804pf4k4tvjuld4y0"><code>*cdkVirtualFor</code> 让模板中可以使用这些上下文变量：</p>
<table>
<thead>
<tr>
<th data-ng_translator_product="100" data-ng_translator_ref_id="879hgi6z9j6t3ten9qwstic6y">上下文变量</th>
<th data-ng_translator_product="100" data-ng_translator_ref_id="ar5q09mdsagdppsbze96eagxl">描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>index</code></td>
<td data-ng_translator_product="100" data-ng_translator_ref_id="46p5yz9wfzsg551s0743amumi">数据源中条目的索引。</td>
</tr>
<tr>
<td><code>count</code></td>
<td data-ng_translator_product="100" data-ng_translator_ref_id="9oyq7nwsrdae5pfo1ukt4bgac">数据源中条目的总数。</td>
</tr>
<tr>
<td><code>first</code></td>
<td data-ng_translator_product="100" data-ng_translator_ref_id="44e1e654w8jogda4uardj3j4v">这是否是数据源中的第一个条目。</td>
</tr>
<tr>
<td><code>last</code></td>
<td data-ng_translator_product="100" data-ng_translator_ref_id="49ogltg5sesxvzbt6lvd5qclh">这是否是数据源中的最后一个条目。</td>
</tr>
<tr>
<td><code>even</code></td>
<td data-ng_translator_product="100" data-ng_translator_ref_id="eo50rcdp9k70l9ztmyn3awmd6"><code>index</code> 是否为偶数。</td>
</tr>
<tr>
<td><code>odd</code></td>
<td data-ng_translator_product="100" data-ng_translator_ref_id="6z804gqj0ecv7sve7lxv85req"><code>index</code> 是否为奇数。</td>
</tr>
</tbody></table>
<p data-ng_translator_product="100" data-ng_translator_ref_id="6aesamhp2mjdpzhunt5tpm4ye">所有这些都是本条目在数据源中的索引，而不是在要渲染的那部分数据的索引。</p>
<div material-docs-example="cdk-virtual-scroll-context"></div>

<p data-ng_translator_product="100" data-ng_translator_ref_id="dos5aw0c0uz2d77gwfbxil1xh">像 <code>*ngFor</code> 的 <code>trackBy</code> 一样，这里也可以指定 <code>trackBy</code> 函数，工作方式也都一样。传给这个 <code>trackBy</code> 的 <code>index</code> 是在数据源中的索引，而不是在要渲染的这部分数据中的索引。</p>

        <h5 id="view-recycling" class="docs-header-link" data-ng_translator_product="100" data-ng_translator_ref_id="2eus6jsmpw3irw1xm80y7usrp">视图回收</h5>
      <p data-ng_translator_product="100" data-ng_translator_ref_id="entzxnip9xsjys3zfm2mbd926">为了提高渲染性能，<code>*cdkVirtualFor</code> 会缓存那些曾经创建过但不再需要的视图。当要创建一个新视图时，会转而复用一个已缓存的视图。可以通过 <code>templateCacheSize</code> 属性来调整视图缓存的大小。把这个大小设置为 <code>0</code> 会禁用缓存。如果你的模板在内存方面很昂贵，你可能会希望减小这个数字，以免在模板缓存上花费太多内存。</p>
<div material-docs-example="cdk-virtual-scroll-template-cache"></div>


        <h5 id="specifying-data" class="docs-header-link" data-ng_translator_product="100" data-ng_translator_ref_id="7t0ec0bmftv2c9f9ya3crp7vq">指定数据</h5>
      <p data-ng_translator_product="100" data-ng_translator_ref_id="2potl1aflr96oxju0ndw4hj4q"><code>*cdkVirtualFor</code> 接受来自 <code>Array</code>、<code>Observable&lt;Array&gt;</code> 或 <code>DataSource</code> 的数据。虚拟滚动的 <code>DataSource</code> 与表格和树组件所用的 <code>DataSource</code> 是同一个。<code>DataSource</code> 只是一个抽象类，它有两个方法：<code>connect</code> 和 <code>disconnect</code>。虚拟滚动视口将调用这个 <code>connect</code> 方法，以接收一个流，这个流会发出要渲染的数据数组。当 viewport 被销毁时，视口会调用 <code>disconnect</code>，这可能是清理连接过程中注册进来的所有订阅的最佳时机。</p>
<div material-docs-example="cdk-virtual-scroll-data-source"></div>


        <h4 id="scrolling-over-fixed-size-items" class="docs-header-link" data-ng_translator_product="100" data-ng_translator_ref_id="4iz6zk9jzh0r8lzet69am1hgd">滚动那些固定大小的条目</h4>
      <p data-ng_translator_product="100" data-ng_translator_ref_id="45xboz5l9wevv2u2iirptyqrb">当所有条目都是固定大小时，你可以使用 <code>FixedSizeVirtualScrollStrategy</code>。可以用 <code>itemSize</code> 指令轻松地将它添加到视口中。这种约束的优点是它可以提供更好的性能，因为在渲染条目时不需要进行测量。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="6phkfqva1l5b9n677b4hgpyhm">固定大小的策略也支持设置一些缓冲区参数，用来决定渲染多少额外内容，也就是视口可见内容之外的部分。第一个参数是 <code>minBufferPx</code>。<code>minBufferPx</code> 是视口必须渲染的最小内容缓冲区数量（以像素为单位）。如果视口检测到要缓冲的内容小于这个数量（未填满），就会立即渲染更多内容。第二个参数是 <code>maxBufferPx</code>。它会告诉视口当检测到需要更多缓冲区的时候要渲染多少个备用缓冲区空间。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="fzi11r4o4tnlz8qyfu96xpwp">这两个缓冲区参数的作用可以用一个例子来说明。假设我们有以下参数：<code>itemSize = 50</code>、<code>minBufferPx = 100</code>、<code>maxBufferPx = 250</code>。当用户滚动浏览内容时，视口就会检测到只剩下 <code>90px</code> 的缓冲区。由于它小于 <code>minBufferPx</code>，所以视口必须渲染更多缓冲区。它必须渲染足够数量的缓冲区，直到其大于等于 <code>maxBufferPx</code>。在这种情况下，它渲染了 4 个条目（额外的 <code>200px</code>），使缓冲区总大小达到 <code>290px</code>，略高于 <code>maxBufferPx</code>。</p>
<div material-docs-example="cdk-virtual-scroll-fixed-buffer"></div>

<p data-ng_translator_product="100" data-ng_translator_ref_id="7c2yzm9er7vc2r35mly48d9wp">其他虚拟滚动策略可以通过扩展 <code>VirtualScrollStrategy</code> 来实现。目前正在 <code>@angular/cdk-experimental</code> 开发一种适用于不同大小元素的自动调整策略，但还没有准备好用于生产环境。</p>

        <h3 id="viewport-orientation" class="docs-header-link" data-ng_translator_product="100" data-ng_translator_ref_id="7xn2s79ne2bcpdxh0wzrym6s5">视口方向</h3>
      <p data-ng_translator_product="100" data-ng_translator_ref_id="4bd12p0jfve8eiqor67yv5gzc">虚拟滚动视口默认为垂直方向，也可以设置为 <code>orientation="horizontal"</code>。在改变方向时，要确保该条目是用 CSS 进行水平布局的。要做到这一点，你可能希望把 <code>.cdk-virtual-scroll-content-wrapper</code> 类作为 CSS 的目标，它是包含待渲染内容的包装元素。</p>
<div material-docs-example="cdk-virtual-scroll-horizontal"></div>


        <h3 id="elements-with-parent-tag-requirements" class="docs-header-link" data-ng_translator_product="100" data-ng_translator_ref_id="5kuxuthpeg1tdn0cb05salk9v">那些对父标签有特定要求的元素</h3>
      <p data-ng_translator_product="100" data-ng_translator_ref_id="e3pr70g7q6okucjuerhvg81fd">某些 HTML 元素（如 <code>&lt;tr&gt;</code> 和 <code>&lt;li&gt;</code>）对它们所在的父元素种类有一些限制。要想对这些类型的元素进行虚拟滚动操作，就要把它们放在合适的父元素中，然后把它们共同包装在 <code>cdk-virtual-scroll-viewport</code> 中。注意，父组件中不要引入额外的空白区（比如通过 <code>margin</code> 或 <code>padding</code>），因为这样会干扰滚动。</p>
<div material-docs-example="cdk-virtual-scroll-dl"></div>


        <h3 id="scrolling-strategies" class="docs-header-link" data-ng_translator_product="100" data-ng_translator_ref_id="5lrwfwpx9kdvdxauzrr1cgza2">滚动策略</h3>
      <p data-ng_translator_product="100" data-ng_translator_ref_id="cehblnh0fq3k18ua46jo89qk1">为了确定整个内容的大小以及它在任何时刻需要实际渲染的内容，视口依赖于所提供的一个 <code>VirtualScrollStrategy</code>。提供它的最简单方式是在视口上使用 <code>itemSize</code> 指令（例如 <code>&lt;cdk-virtual-scroll-viewport itemSize="50"&gt;</code>）。但是，也可以通过创建一个实现 <code>VirtualScrollStrategy</code> 接口的类来提供自定义策略，并在包含此视口的组件上把它提供为 <code>VIRTUAL_SCROLL_STRATEGY</code>。</p>
<div material-docs-example="cdk-virtual-scroll-custom-strategy"></div>


        <h3 id="append-only-mode" class="docs-header-link" data-ng_translator_product="100" data-ng_translator_ref_id="65c6kjop9ky959ik7350kz4ud">仅追加模式</h3>
      <p data-ng_translator_product="100" data-ng_translator_ref_id="60cv7h0j4ufb7y9zivwpn34jc">渲染非平凡条目的虚拟滚动视口可能会发现，在用户滚动时简单地附加到列表而用不删除已渲染的视图会更高效。 <code>appendOnly</code> 输入确保已渲染的视图在滚动出视图后仍保留在 DOM 中。</p>
<div material-docs-example="cdk-virtual-scroll-append-only"></div>


        <h3 id="separate-viewport-and-scrolling-element" class="docs-header-link" data-ng_translator_product="100" data-ng_translator_ref_id="7o20kx9v8b6b5mbyg51nr63l1">单独的视口和滚动元素</h3>
      <p data-ng_translator_product="100" data-ng_translator_ref_id="2546fh1hqu2rpnu197twjt9dg">默认情况下，虚拟滚动视口本身就会充当滚动元素。但是，在某些情况下，你可能希望让此视口滚动其父元素之一。例如，如果你想要一些非虚拟化内容，用户可以在虚拟化内容之前或之后滚动浏览。</p>
<p data-ng_translator_product="100" data-ng_translator_ref_id="dpdcm95cgpchw5plwfjdtct2h">要将 <code>cdk-vritual-scroll-viewport</code> 配置为使用其父元素之一作为滚动元素，请把 <code>cdkVirtualScrollingElement</code> 应用于那个父元素。</p>
<div material-docs-example="cdk-virtual-scroll-parent-scrolling"></div>

<p data-ng_translator_product="100" data-ng_translator_ref_id="e6u2d14ad29di7fba7goi2yxb">另一种常见的情况是使用窗口本身作为滚动元素。这在移动设备上通常是更好的用户体验，因为它允许浏览器 chrome 滚动消失。要使用窗口作为滚动元素，请将 
<code>scrollWindow</code> 属性添加到 
<code>cdk-virtual-scroll-viewport</code>。</p>
<div material-docs-example="cdk-virtual-scroll-window-scrolling"></div>
</div>