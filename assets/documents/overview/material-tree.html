<html><head></head><body><div class="docs-markdown"><p class="docs-markdown-p" translation-result="on"><code class="docs-markdown-code">mat-tree</code> 提供了一个 Material Design 风格的树，它可用于显示层次型数据。</p><p class="docs-markdown-p" translation-origin="off">The <code class="docs-markdown-code">mat-tree</code> provides a Material Design styled tree that can be used to display hierarchy data.</p><p class="docs-markdown-p" translation-result="on">树控件基于 CDK 的树控件构建，并使用相似的接口来表示其数据源和模板。只是它们的元素和属性选择器会用 <code class="docs-markdown-code">mat-</code> 前缀，而不是 <code class="docs-markdown-code">cdk-</code> 前缀。</p><p class="docs-markdown-p" translation-origin="off">This tree builds on the foundation of the CDK tree and uses a similar interface for its data source input and template, except that its element and attribute selectors will be prefixed with <code class="docs-markdown-code">mat-</code> instead of <code class="docs-markdown-code">cdk-</code>.</p><p class="docs-markdown-p" translation-result="on">有两种类型的树：扁平树和嵌套树。这两种树的 DOM 结构是不同的。</p><p class="docs-markdown-p" translation-origin="off">There are two types of trees: Flat tree and nested tree. The DOM structures are different for these two types of trees.</p><h4 id="flat-tree" class="docs-header-link docs-markdown-h4" translation-result="on"><span header-link="-"></span> 扁平树</h4><h4 class="docs-header-link docs-markdown-h4" translation-origin="off"><span header-link="flat-tree"></span> Flat tree</h4><p class="docs-markdown-p" translation-result="on">在扁平树中，其层次是扁平的，它的节点不会渲染在其它节点内部，而是渲染成兄弟节点。 <code class="docs-markdown-code">TreeFlattener</code> 的实例用来根据层次型数据生成扁平的条目列表。 每个节点的级别都是从其 <code class="docs-markdown-code">TreeControl</code> 中的 <code class="docs-markdown-code">getLevel</code> 方法中读取的；这个级别可用来设置节点样式，使其缩进到适当的级别。</p><p class="docs-markdown-p" translation-origin="off">In a flat tree, the hierarchy is flattened; nodes are not rendered inside of each other, but instead are rendered as siblings in sequence. An instance of <code class="docs-markdown-code">TreeFlattener</code> is used to generate the flat list of items from hierarchical data. The "level" of each tree node is read through the <code class="docs-markdown-code">getLevel</code> method of the <code class="docs-markdown-code">TreeControl</code>; this level can be used to style the node such that it is indented to the appropriate level.</p><pre class="docs-markdown-pre"><code class="lang-html docs-markdown-code"><span class="hljs-tag">&lt;<span class="hljs-name">mat-tree</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">mat-tree-node</span>&gt;</span> parent node <span class="hljs-tag">&lt;/<span class="hljs-name">mat-tree-node</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">mat-tree-node</span>&gt;</span> -- child node1 <span class="hljs-tag">&lt;/<span class="hljs-name">mat-tree-node</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">mat-tree-node</span>&gt;</span> -- child node2 <span class="hljs-tag">&lt;/<span class="hljs-name">mat-tree-node</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mat-tree</span>&gt;</span>
</code></pre><div material-docs-example="tree-flat-overview"></div><p class="docs-markdown-p" translation-result="on">扁平树通常更容易设置样式和审查元素。它们对各种滚动更加友好 —— 比如无尽滚动或虚拟滚动。</p><p class="docs-markdown-p" translation-origin="off">Flat trees are generally easier to style and inspect. They are also more friendly to scrolling variations, such as infinite or virtual scrolling</p><h4 id="nested-tree" class="docs-header-link docs-markdown-h4" translation-result="on"><span header-link="-"></span> 嵌套树</h4><h4 class="docs-header-link docs-markdown-h4" translation-origin="off"><span header-link="nested-tree"></span> Nested tree</h4><p class="docs-markdown-p" translation-result="on">在嵌套树中，子节点会放在其父节点 DOM 元素的内部。父节点有一个出口（outlet），用来存放其所有子节点。</p><p class="docs-markdown-p" translation-origin="off">In Nested tree, children nodes are placed inside their parent node in DOM. The parent node has an outlet to keep all the children nodes.</p><pre class="docs-markdown-pre"><code class="lang-html docs-markdown-code"><span class="hljs-tag">&lt;<span class="hljs-name">mat-tree</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">mat-nested-tree-node</span>&gt;</span>
     parent node
     <span class="hljs-tag">&lt;<span class="hljs-name">mat-nested-tree-node</span>&gt;</span> -- child node1 <span class="hljs-tag">&lt;/<span class="hljs-name">mat-nested-tree-node</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">mat-nested-tree-node</span>&gt;</span> -- child node2 <span class="hljs-tag">&lt;/<span class="hljs-name">mat-nested-tree-node</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">mat-nested-tree-node</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mat-tree</span>&gt;</span>
</code></pre><div material-docs-example="tree-nested-overview"></div><p class="docs-markdown-p" translation-result="on">当以扁平节点的形式难以可视化地表示层次关系时，使用嵌套树会更容易。</p><p class="docs-markdown-p" translation-origin="off">Nested trees are easier to work with when hierarchical relationships are visually represented in ways that would be difficult to accomplish with flat nodes.</p><h3 id="features" class="docs-header-link docs-markdown-h3" translation-result="on"><span header-link="-"></span> 特性</h3><h3 class="docs-header-link docs-markdown-h3" translation-origin="off"><span header-link="features"></span> Features</h3><p class="docs-markdown-p" translation-result="on"><code class="docs-markdown-code">&lt;mat-tree&gt;</code> 本身只关心树形结构的渲染工作。通过在节点模板内添加行为（比如填充 <code class="docs-markdown-code">padding</code> 和切换 <code class="docs-markdown-code">toggle</code>），可以在标准树的基础上构建附加功能。 那些能影响渲染数据的交互（比如展开/折叠）应该能通过表格的数据源进行传播。</p><p class="docs-markdown-p" translation-origin="off">The <code class="docs-markdown-code">&lt;mat-tree&gt;</code> itself only deals with the rendering of a tree structure. Additional features can be built on top of the tree by adding behavior inside node templates (e.g., padding and toggle). Interactions that affect the rendered data (such as expand/collapse) should be propagated through the table's data source.</p><h3 id="treecontrol" class="docs-header-link docs-markdown-h3" translation-result="on"><span header-link="-treecontrol"></span> 树控件 TreeControl</h3><h3 class="docs-header-link docs-markdown-h3" translation-origin="off"><span header-link="treecontrol"></span> TreeControl</h3><p class="docs-markdown-p" translation-result="on"><code class="docs-markdown-code">TreeControl</code> 控制树节点的展开/折叠状态。用户可以通过数控件来递归的展开/折叠树节点。 对于嵌套树的节点，要把一个 <code class="docs-markdown-code">getChildren</code> 函数传给 <code class="docs-markdown-code">NestedTreeControl</code>，来让它能递归使用。 <code class="docs-markdown-code">getChildren</code> 函数可以返回一个指定节点上子节点的 <code class="docs-markdown-code">Observable</code>或其子节点的数组。 对于扁平树的节点，要把 <code class="docs-markdown-code">getLevel</code> 和 <code class="docs-markdown-code">isExpandable</code> 函数传给 <code class="docs-markdown-code">FlatTreeControl</code>，来让它能递归使用。</p><p class="docs-markdown-p" translation-origin="off">The <code class="docs-markdown-code">TreeControl</code> controls the expand/collapse state of tree nodes. Users can expand/collapse a tree node recursively through tree control. For nested tree node, <code class="docs-markdown-code">getChildren</code> function need to pass to the <code class="docs-markdown-code">NestedTreeControl</code> to make it work recursively. The <code class="docs-markdown-code">getChildren</code> function may return an observable of children for a given node, or an array of children. For flattened tree node, <code class="docs-markdown-code">getLevel</code> and <code class="docs-markdown-code">isExpandable</code> functions need to pass to the <code class="docs-markdown-code">FlatTreeControl</code> to make it work recursively.</p><h3 id="toggle" class="docs-header-link docs-markdown-h3" translation-result="on"><span header-link="-"></span> 开关</h3><h3 class="docs-header-link docs-markdown-h3" translation-origin="off"><span header-link="toggle"></span> Toggle</h3><p class="docs-markdown-p" translation-result="on">可以把 <code class="docs-markdown-code">matTreeNodeToggle</code> 添加到树节点模板中，以展开/折叠树节点。此开关可以切换 <code class="docs-markdown-code">TreeControl</code> 中的展开/折叠函数，还能把 <code class="docs-markdown-code">[matTreeNodeToggleRecursive]</code> 设置为 <code class="docs-markdown-code">true</code> 来递归展开/折叠树节点。</p><p class="docs-markdown-p" translation-origin="off">A <code class="docs-markdown-code">matTreeNodeToggle</code> can be added in the tree node template to expand/collapse the tree node. The toggle toggles the expand/collapse functions in <code class="docs-markdown-code">TreeControl</code> and is able to expand/collapse a tree node recursively by setting <code class="docs-markdown-code">[matTreeNodeToggleRecursive]</code> to <code class="docs-markdown-code">true</code>.</p><p class="docs-markdown-p" translation-result="on">此开关可以放在树节点中的任何地方，并且只能通过点击（<code class="docs-markdown-code">click</code>）操作进行切换。</p><p class="docs-markdown-p" translation-origin="off">The toggle can be placed anywhere in the tree node, and is only toggled by <code class="docs-markdown-code">click</code> action.</p><h3 id="padding-flat-tree-only-" class="docs-header-link docs-markdown-h3" translation-result="on"><span header-link="-"></span> 填充（只对扁平树）</h3><h3 class="docs-header-link docs-markdown-h3" translation-origin="off"><span header-link="padding-flat-tree-only-"></span> Padding (Flat tree only)</h3><p class="docs-markdown-p" translation-result="on"><code class="docs-markdown-code">matTreeNodePadding</code> 可以放在扁平树的节点模板中，以展示扁平树节点的 <code class="docs-markdown-code">level</code> 信息。</p><p class="docs-markdown-p" translation-origin="off">The <code class="docs-markdown-code">matTreeNodePadding</code> can be placed in a flat tree's node template to display the <code class="docs-markdown-code">level</code> information of a flat tree node.</p><p class="docs-markdown-p" translation-result="on">嵌套树不需要进行填充，因为 DOM 中的层次结构就能很容易地加上它。</p><p class="docs-markdown-p" translation-origin="off">Nested tree does not need this padding since padding can be easily added to the hierarchy structure in DOM.</p><h3 id="accessibility" class="docs-header-link docs-markdown-h3" translation-result="on"><span header-link="-"></span> 无障碍性</h3><h3 class="docs-header-link docs-markdown-h3" translation-origin="off"><span header-link="accessibility"></span> Accessibility</h3><p class="docs-markdown-p" translation-result="on">没有文本或标签的树应该通过 <code class="docs-markdown-code">aria-label</code> 或 <code class="docs-markdown-code">aria-labelledby</code> 给出一个有意义的标签。如果没有指定，则 <code class="docs-markdown-code">aria-readonly</code> 会默认为 <code class="docs-markdown-code">true</code>。</p><p class="docs-markdown-p" translation-origin="off">Trees without text or labels should be given a meaningful label via <code class="docs-markdown-code">aria-label</code> or <code class="docs-markdown-code">aria-labelledby</code>. The <code class="docs-markdown-code">aria-readonly</code> defaults to <code class="docs-markdown-code">true</code> if it's not set.</p><p class="docs-markdown-p" translation-result="on">树的角色是 <code class="docs-markdown-code">tree</code>。 父节点会带有 <code class="docs-markdown-code">role="group"</code>，而叶节点会带有 <code class="docs-markdown-code">role="treeitem"</code>。</p><p class="docs-markdown-p" translation-origin="off">Tree's role is <code class="docs-markdown-code">tree</code>. Parent nodes are given <code class="docs-markdown-code">role="group"</code>, while leaf nodes are given <code class="docs-markdown-code">role="treeitem"</code></p><p class="docs-markdown-p" translation-result="on"><code class="docs-markdown-code">mat-tree</code> 不会自行管理任何焦点/键盘交互。 开发者可以根据需求为应用自行添加焦点/键盘交互。</p><p class="docs-markdown-p" translation-origin="off"><code class="docs-markdown-code">mat-tree</code> does not manage any focus/keyboard interaction on its own. Users can add desired focus/keyboard interactions in their application.</p></div></body></html>