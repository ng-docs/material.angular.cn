<html><head></head><body><div class="docs-markdown"><p class="docs-markdown-p" translation-result="on"><code class="docs-markdown-code">a11y</code> 包提供了许多提高无障碍性（可访问性）的工具，如下所述。</p><p class="docs-markdown-p" translation-origin="off">The <code class="docs-markdown-code">a11y</code> package provides a number of tools to improve accessibility, described below.</p><h2 class="docs-markdown-h2" id="listkeymanager" translation-result="on">ListKeyManager（列表键盘管理器）</h2><h2 class="docs-markdown-h2" translation-origin="off">ListKeyManager</h2><p class="docs-markdown-p" translation-result="on"><code class="docs-markdown-code">ListKeyManager</code> 可以通过键盘交互来管理条目列表中的激活选项。主要针对带有 <code class="docs-markdown-code">role="menu"</code> 或 <code class="docs-markdown-code">role="listbox"</code> 的组件。</p><p class="docs-markdown-p" translation-origin="off"><code class="docs-markdown-code">ListKeyManager</code> manages the active option in a list of items based on keyboard interaction. Intended to be used with components that correspond to a <code class="docs-markdown-code">role="menu"</code> or <code class="docs-markdown-code">role="listbox"</code> pattern.</p><h3 id="basic-usage" class="docs-header-link docs-markdown-h3" translation-result="on"><span header-link="-"></span> 基本用法</h3><h3 class="docs-header-link docs-markdown-h3" translation-origin="off"><span header-link="basic-usage"></span> Basic usage</h3><p class="docs-markdown-p" translation-result="on">那些使用 <code class="docs-markdown-code">ListKeyManager</code> 的组件通常要做三件事：</p><p class="docs-markdown-p" translation-origin="off">Any component that uses a <code class="docs-markdown-code">ListKeyManager</code> will generally do three things:</p><ul class="docs-markdown-ul"><li class="docs-markdown-li"><p class="docs-markdown-p" translation-result="on">为要管理的条目创建一个 <code class="docs-markdown-code">@ViewChildren</code> 查询。</p><p class="docs-markdown-p" translation-origin="off">Create a <code class="docs-markdown-code">@ViewChildren</code> query for the options being managed.</p></li><li class="docs-markdown-li"><p class="docs-markdown-p" translation-result="on">初始化 <code class="docs-markdown-code">ListKeyManager</code>，并传入这些选项。</p><p class="docs-markdown-p" translation-origin="off">Initialize the <code class="docs-markdown-code">ListKeyManager</code>, passing in the options.</p></li><li class="docs-markdown-li"><p class="docs-markdown-p" translation-result="on">把键盘事件从被管理的组件转发到 <code class="docs-markdown-code">ListKeyManager</code>。</p><p class="docs-markdown-p" translation-origin="off">Forward keyboard events from the managed component to the <code class="docs-markdown-code">ListKeyManager</code>.</p></li></ul><p class="docs-markdown-p" translation-result="on">每个选项都应该实现 <code class="docs-markdown-code">ListKeyManagerOption</code> 接口：</p><p class="docs-markdown-p" translation-origin="off">Each option should implement the <code class="docs-markdown-code">ListKeyManagerOption</code> interface:</p><pre class="docs-markdown-pre"><code class="lang-ts docs-markdown-code"><span class="hljs-keyword">interface</span> ListKeyManagerOption {
  disabled?: <span class="hljs-built_in">boolean</span>;
  getLabel?(): <span class="hljs-built_in">string</span>;
}
</code></pre><h3 id="wrapping" class="docs-header-link docs-markdown-h3" translation-result="on"><span header-link="-"></span> 包装</h3><h3 class="docs-header-link docs-markdown-h3" translation-origin="off"><span header-link="wrapping"></span> Wrapping</h3><p class="docs-markdown-p" translation-result="on">可以通过<code class="docs-markdown-code">withWrap</code>方法对<code class="docs-markdown-code">withWrap</code>选项进行导航</p><p class="docs-markdown-p" translation-origin="off">Navigation through options can be made to wrap via the <code class="docs-markdown-code">withWrap</code> method</p><pre class="docs-markdown-pre"><code class="lang-ts docs-markdown-code"><span class="hljs-keyword">this</span>.keyManager = <span class="hljs-keyword">new</span> FocusKeyManager(...).withWrap();
</code></pre><h3 id="types-of-key-managers" class="docs-header-link docs-markdown-h3" translation-result="on"><span header-link="-"></span> 键盘管理器的类型</h3><h3 class="docs-header-link docs-markdown-h3" translation-origin="off"><span header-link="types-of-key-managers"></span> Types of key managers</h3><p class="docs-markdown-p" translation-result="on"><code class="docs-markdown-code">ListKeyManager</code> 有两种变体形式：<code class="docs-markdown-code">FocusKeyManager</code> 和 <code class="docs-markdown-code">ActiveDescendantKeyManager</code>。</p><p class="docs-markdown-p" translation-origin="off">There are two varieties of <code class="docs-markdown-code">ListKeyManager</code>, <code class="docs-markdown-code">FocusKeyManager</code> and <code class="docs-markdown-code">ActiveDescendantKeyManager</code>.</p><h4 id="focuskeymanager" class="docs-header-link docs-markdown-h4" translation-result="on"><span header-link="focuskeymanager-"></span> FocusKeyManager（焦点型键盘管理器）</h4><h4 class="docs-header-link docs-markdown-h4" translation-origin="off"><span header-link="focuskeymanager"></span> FocusKeyManager</h4><p class="docs-markdown-p" translation-result="on">当这些选项能直接接收浏览器焦点时使用。每个受管理的选项都必须实现 <code class="docs-markdown-code">FocusableOption</code> 接口：</p><p class="docs-markdown-p" translation-origin="off">Used when options will directly receive browser focus. Each item managed must implement the <code class="docs-markdown-code">FocusableOption</code> interface:</p><pre class="docs-markdown-pre"><code class="lang-ts docs-markdown-code"><span class="hljs-keyword">interface</span> FocusableOption <span class="hljs-keyword">extends</span> ListKeyManagerOption {
  focus(): <span class="hljs-built_in">void</span>;
}
</code></pre><h4 id="activedescendantkeymanager" class="docs-header-link docs-markdown-h4" translation-result="on"><span header-link="activedescendantkeymanager-"></span> ActiveDescendantKeyManager（激活选项型键盘管理器）</h4><h4 class="docs-header-link docs-markdown-h4" translation-origin="off"><span header-link="activedescendantkeymanager"></span> ActiveDescendantKeyManager</h4><p class="docs-markdown-p" translation-result="on">当这些选项由 <code class="docs-markdown-code">aria-activedescendant</code> 标为激活时使用。每个受管理的选项都必须实现 <code class="docs-markdown-code">Highlightable</code> 接口：</p><p class="docs-markdown-p" translation-origin="off">Used when options will be marked as active via <code class="docs-markdown-code">aria-activedescendant</code>. Each item managed must implement the <code class="docs-markdown-code">Highlightable</code> interface:</p><pre class="docs-markdown-pre"><code class="lang-ts docs-markdown-code"><span class="hljs-keyword">interface</span> Highlightable <span class="hljs-keyword">extends</span> ListKeyManagerOption {
  setActiveStyles(): <span class="hljs-built_in">void</span>;
  setInactiveStyles(): <span class="hljs-built_in">void</span>;
}
</code></pre><p class="docs-markdown-p" translation-result="on">每个条目都必须有一个 ID，用于绑定到列表框或菜单的 <code class="docs-markdown-code">aria-activedescendant</code>。</p><p class="docs-markdown-p" translation-origin="off">Each item must also have an ID bound to the listbox's or menu's <code class="docs-markdown-code">aria-activedescendant</code>.</p><h2 class="docs-markdown-h2" id="focustrap" translation-result="on">FocusTrap（焦点陷阱）</h2><h2 class="docs-markdown-h2" translation-origin="off">FocusTrap</h2><p class="docs-markdown-p" translation-result="on"><code class="docs-markdown-code">cdkTrapFocus</code> 指令用于捕获一个元素中的 <code class="docs-markdown-code">Tab</code> 键焦点。这可以用来创建<a href="https://www.w3.org/TR/wai-aria-practices-1.1/#dialog_modal" class="docs-markdown-a">模态对话框</a>等组件的无障碍体验，这时候必须限制焦点的移动。</p><p class="docs-markdown-p" translation-origin="off">The <code class="docs-markdown-code">cdkTrapFocus</code> directive traps <kbd>Tab</kbd> key focus within an element. This is intended to be used to create accessible experience for components like <a href="https://www.w3.org/TR/wai-aria-practices-1.1/#dialog_modal" class="docs-markdown-a">modal dialogs</a>, where focus must be constrained.</p><p class="docs-markdown-p" translation-result="on">该指令声明在 <code class="docs-markdown-code">A11yModule</code> 中。</p><p class="docs-markdown-p" translation-origin="off">This directive is declared in <code class="docs-markdown-code">A11yModule</code>.</p><h3 id="example" class="docs-header-link docs-markdown-h3" translation-result="on"><span header-link="-"></span> 例子</h3><h3 class="docs-header-link docs-markdown-h3" translation-origin="off"><span header-link="example"></span> Example</h3><pre class="docs-markdown-pre"><code class="lang-html docs-markdown-code"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"my-inner-dialog-content"</span> <span class="hljs-attr">cdkTrapFocus</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- Tab and Shift + Tab will not leave this element. --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre><p class="docs-markdown-p" translation-result="on">该指令不会阻止焦点因鼠标交互而移出陷阱区域。</p><p class="docs-markdown-p" translation-origin="off">This directive will not prevent focus from moving out of the trapped region due to mouse interaction.</p><h3 id="regions" class="docs-header-link docs-markdown-h3" translation-result="on"><span header-link="-"></span> 区域</h3><h3 class="docs-header-link docs-markdown-h3" translation-origin="off"><span header-link="regions"></span> Regions</h3><p class="docs-markdown-p" translation-result="on">可以使用 <code class="docs-markdown-code">cdkFocusRegionStart</code>，<code class="docs-markdown-code">cdkFocusRegionEnd</code> 和 <code class="docs-markdown-code">cdkFocusInitial</code> 等 DOM 属性，来显式声明一个初始元素。<code class="docs-markdown-code">cdkFocusInitial</code> 用于指定在初始化该区域时哪个元素会获得焦点。<code class="docs-markdown-code">cdkFocusRegionStart</code> 和 <code class="docs-markdown-code">cdkFocusRegionEnd</code> 定义了获得焦点陷阱的区域。使用 tab 键的时候，焦点会在这个区域内移动，并在区域的两端自动回卷。</p><p class="docs-markdown-p" translation-origin="off">Regions can be declared explicitly with an initial focus element by using the <code class="docs-markdown-code">cdkFocusRegionStart</code>, <code class="docs-markdown-code">cdkFocusRegionEnd</code> and <code class="docs-markdown-code">cdkFocusInitial</code> DOM attributes. <code class="docs-markdown-code">cdkFocusInitial</code> specifies the element that will receive focus upon initialization of the region. <code class="docs-markdown-code">cdkFocusRegionStart</code> and <code class="docs-markdown-code">cdkFocusRegionEnd</code> define the region within which focus will be trapped. When using the tab key, focus will move through this region and wrap around on either end.</p><p class="docs-markdown-p" translation-result="on">例如：</p><p class="docs-markdown-p" translation-origin="off">For example:</p><pre class="docs-markdown-pre"><code class="lang-html docs-markdown-code"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">mat-list-item</span> <span class="hljs-attr">routerLink</span> <span class="hljs-attr">cdkFocusRegionStart</span>&gt;</span>Focus region start<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">mat-list-item</span> <span class="hljs-attr">routerLink</span>&gt;</span>Link<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">mat-list-item</span> <span class="hljs-attr">routerLink</span> <span class="hljs-attr">cdkFocusInitial</span>&gt;</span>Initially focused<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">mat-list-item</span> <span class="hljs-attr">routerLink</span> <span class="hljs-attr">cdkFocusRegionEnd</span>&gt;</span>Focus region end<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
</code></pre><h2 class="docs-markdown-h2" id="interactivitychecker" translation-result="on">InteractivityChecker（交互检查器）</h2><h2 class="docs-markdown-h2" translation-origin="off">InteractivityChecker</h2><p class="docs-markdown-p" translation-result="on"><code class="docs-markdown-code">InteractivityChecker</code> 用于检查元素的交互性，它会捕获禁用（disabled）、可见（visible）、（可 tab）tabbable 和可获得焦点（focusable）状态，以便检查无障碍性。更多信息，请参阅 API 文档。</p><p class="docs-markdown-p" translation-origin="off"><code class="docs-markdown-code">InteractivityChecker</code> is used to check the interactivity of an element, capturing disabled, visible, tabbable, and focusable states for accessibility purposes. See the API docs for more details.</p><h2 class="docs-markdown-h2" id="liveannouncer" translation-result="on">LiveAnnouncer（直播播音员）</h2><h2 class="docs-markdown-h2" translation-origin="off">LiveAnnouncer</h2><p class="docs-markdown-p" translation-result="on"><code class="docs-markdown-code">LiveAnnouncer</code> 用于通过 <code class="docs-markdown-code">aria-live</code> 区域为屏幕阅读器用户播报信息。关于 <code class="docs-markdown-code">aria-live</code> 区域的详细信息，请参见 <a href="https://www.w3.org/TR/wai-aria/states_and_properties#aria-live" class="docs-markdown-a">W3C 的 WAI-ARIA</a> 。</p><p class="docs-markdown-p" translation-origin="off"><code class="docs-markdown-code">LiveAnnouncer</code> is used to announce messages for screen-reader users using an <code class="docs-markdown-code">aria-live</code> region. See <a href="https://www.w3.org/TR/wai-aria/states_and_properties#aria-live" class="docs-markdown-a">the W3C's WAI-ARIA</a> for more information on aria-live regions.</p><h3 id="example" class="docs-header-link docs-markdown-h3" translation-result="on"><span header-link="-"></span> 例子</h3><h3 class="docs-header-link docs-markdown-h3" translation-origin="off"><span header-link="example"></span> Example</h3><pre class="docs-markdown-pre"><code class="lang-ts docs-markdown-code"><span class="hljs-meta">@Component</span>({...})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> MyComponent {

 <span class="hljs-keyword">constructor</span>(<span class="hljs-params">liveAnnouncer: LiveAnnouncer</span>) {
   liveAnnouncer.announce(<span class="hljs-string">"Hey Google"</span>);
 }
}
</code></pre><h2 class="docs-markdown-h2" id="focusmonitor" translation-result="on">FocusMonitor（焦点管理器）</h2><h2 class="docs-markdown-h2" translation-origin="off">FocusMonitor</h2><p class="docs-markdown-p" translation-result="on"><code class="docs-markdown-code">FocusMonitor</code> 是一个可注入的服务，可以用来监听元素焦点状态的变化。它比单纯监听 <code class="docs-markdown-code">focus</code> 或 <code class="docs-markdown-code">blur</code> 事件更有意义，因为它会告诉你该元素是如何获得焦点的（通过鼠标，键盘，触摸或编程方式）。如果需要，它还允许监听各级子元素。</p><p class="docs-markdown-p" translation-origin="off">The <code class="docs-markdown-code">FocusMonitor</code> is an injectable service that can be used to listen for changes in the focus state of an element. It's more powerful than just listening for <code class="docs-markdown-code">focus</code> or <code class="docs-markdown-code">blur</code> events because it tells you how the element was focused (via mouse, keyboard, touch, or programmatically). It also allows listening for focus on descendant elements if desired.</p><p class="docs-markdown-p" translation-result="on">要监听某个元素的焦点变化，可以用 <code class="docs-markdown-code">monitor</code> 方法传入要监控的元素和一个可选的逻辑标志 <code class="docs-markdown-code">checkChildren</code>。给 <code class="docs-markdown-code">checkChildren</code> 传入 <code class="docs-markdown-code">true</code> 会告诉 <code class="docs-markdown-code">FocusMonitor</code> ：如果该元素的任何各级子元素有焦点，就认为该元素有焦点。如果没有指定，该选项默认为 <code class="docs-markdown-code">false</code> 。<code class="docs-markdown-code">monitor</code> 方法会返回一个可观察对象，当焦点状态改变时，该对象会发送一个 <code class="docs-markdown-code">FocusOrigin</code>。 <code class="docs-markdown-code">FocusOrigin</code> 是下列值之一：</p><p class="docs-markdown-p" translation-origin="off">To listen for focus changes on an element, use the <code class="docs-markdown-code">monitor</code> method which takes an element to monitor and an optional boolean flag <code class="docs-markdown-code">checkChildren</code>. Passing true for <code class="docs-markdown-code">checkChildren</code> will tell the <code class="docs-markdown-code">FocusMonitor</code> to consider the element focused if any of its descendants are focused. This option defaults to <code class="docs-markdown-code">false</code> if not specified. The <code class="docs-markdown-code">monitor</code> method will return an Observable that emits the <code class="docs-markdown-code">FocusOrigin</code> whenever the focus state changes. The <code class="docs-markdown-code">FocusOrigin</code> will be one of the following:</p><ul class="docs-markdown-ul"><li class="docs-markdown-li"><p class="docs-markdown-p" translation-result="on"><code class="docs-markdown-code">'mouse'</code>表示该元素是通过鼠标获得焦点的</p><p class="docs-markdown-p" translation-origin="off"><code class="docs-markdown-code">'mouse'</code> indicates the element was focused with the mouse</p></li><li class="docs-markdown-li"><p class="docs-markdown-p" translation-result="on"><code class="docs-markdown-code">'keyboard'</code>表示该元素是通过键盘获得焦点的</p><p class="docs-markdown-p" translation-origin="off"><code class="docs-markdown-code">'keyboard'</code> indicates the element was focused with the keyboard</p></li><li class="docs-markdown-li"><p class="docs-markdown-p" translation-result="on"><code class="docs-markdown-code">'touch'</code>表示该元素是通过触摸屏获得焦点的</p><p class="docs-markdown-p" translation-origin="off"><code class="docs-markdown-code">'touch'</code> indicates the element was focused by touching on a touchscreen</p></li><li class="docs-markdown-li"><p class="docs-markdown-p" translation-result="on"><code class="docs-markdown-code">'program'</code>表示该元素是通过编程方式获得焦点的</p><p class="docs-markdown-p" translation-origin="off"><code class="docs-markdown-code">'program'</code> indicates the element was focused programmatically</p></li><li class="docs-markdown-li"><p class="docs-markdown-p" translation-result="on"><code class="docs-markdown-code">null</code>表示该元素失去了焦点</p><p class="docs-markdown-p" translation-origin="off"><code class="docs-markdown-code">null</code> indicates the element was blurred</p></li></ul><p class="docs-markdown-p" translation-result="on">除了在可观察对象中发送信息之外，<code class="docs-markdown-code">FocusMonitor</code> 还会自动对有焦点的元素元素应用一些 CSS 类。如果该元素拥有焦点，它会添加 <code class="docs-markdown-code">.cdk-focused</code> 类，并进一步添加<code class="docs-markdown-code">.cdk-${origin}-focused</code> 类来表明元素是如何获得焦点的（ <code class="docs-markdown-code">${origin}</code> 是 <code class="docs-markdown-code">mouse</code>、<code class="docs-markdown-code">keyboard</code>、<code class="docs-markdown-code">touch</code> 或 <code class="docs-markdown-code">program</code> 之一）。</p><p class="docs-markdown-p" translation-origin="off">In addition to emitting on the observable, the <code class="docs-markdown-code">FocusMonitor</code> will automatically apply CSS classes to the element when focused. It will add <code class="docs-markdown-code">.cdk-focused</code> if the element is focused and will further add <code class="docs-markdown-code">.cdk-${origin}-focused</code> (with <code class="docs-markdown-code">${origin}</code> being <code class="docs-markdown-code">mouse</code>, <code class="docs-markdown-code">keyboard</code>, <code class="docs-markdown-code">touch</code>, or <code class="docs-markdown-code">program</code>) to indicate how the element was focused.</p><p class="docs-markdown-p" translation-result="on">注意：目前，这个可观察对象会在 Angular Zone <em>之外</em>发出 <code class="docs-markdown-code">FocusMonitor</code>。因此，如果你在其订阅中调用了 <code class="docs-markdown-code">markForCheck</code>，那就必须把自己放回 Angular Zone 内部。</p><p class="docs-markdown-p" translation-origin="off">Note: currently the <code class="docs-markdown-code">FocusMonitor</code> emits on the observable <em>outside</em> of the Angular zone. Therefore if you <code class="docs-markdown-code">markForCheck</code> in the subscription you must put yourself back in the Angular zone.</p><pre class="docs-markdown-pre"><code class="lang-ts docs-markdown-code">focusMonitor.monitor(el).subscribe(<span class="hljs-function"><span class="hljs-params">origin</span> =&gt;</span> <span class="hljs-keyword">this</span>.ngZone.run(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-comment">/* ... */</span> ));
</code></pre><p class="docs-markdown-p" translation-result="on">任何通过调用 <code class="docs-markdown-code">monitor</code> 来监控的元素最终都要对这个元素调用 <code class="docs-markdown-code">stopMonitoring</code> 来取消监控。</p><p class="docs-markdown-p" translation-origin="off">Any element that is monitored by calling <code class="docs-markdown-code">monitor</code> should eventually be unmonitored by calling <code class="docs-markdown-code">stopMonitoring</code> with the same element.</p><div material-docs-example="focus-monitor-overview"></div><p class="docs-markdown-p" translation-result="on">当使用 <code class="docs-markdown-code">FocusMonitor</code> 的 <code class="docs-markdown-code">focusVia</code> 方法来通过编程的方式设置焦点时，可能会伪造一个 <code class="docs-markdown-code">FocusMonitor</code>。使用该方法时要传入一个希望获得焦点的元素和 <code class="docs-markdown-code">FocusOrigin</code>。如果 <code class="docs-markdown-code">FocusMonitor</code> 当前正在监视要获得焦点的元素，它就会报告传入的这个 <code class="docs-markdown-code">FocusOrigin</code>。如果当前没有监视该元素，它就会像正常情况下一样获得焦点。</p><p class="docs-markdown-p" translation-origin="off">It is possible to falsify the <code class="docs-markdown-code">FocusOrigin</code> when setting the focus programmatically by using the <code class="docs-markdown-code">focusVia</code> method of <code class="docs-markdown-code">FocusMonitor</code>. This method accepts an element to focus and the <code class="docs-markdown-code">FocusOrigin</code> to use. If the element being focused is currently being monitored by the <code class="docs-markdown-code">FocusMonitor</code> it will report the <code class="docs-markdown-code">FocusOrigin</code> that was passed in. If the element is not currently being monitored it will just be focused like normal.</p><div material-docs-example="focus-monitor-focus-via"></div><h3 id="cdkmonitorelementfocus-and-cdkmonitorsubtreefocus" class="docs-header-link docs-markdown-h3" translation-result="on"><span header-link="cdkmonitorelementfocus-cdkmonitorsubtreefocus-"></span> cdkMonitorElementFocus（监视元素焦点） 和 cdkMonitorSubtreeFocus（监视子树焦点）</h3><h3 class="docs-header-link docs-markdown-h3" translation-origin="off"><span header-link="cdkmonitorelementfocus-and-cdkmonitorsubtreefocus"></span> cdkMonitorElementFocus and cdkMonitorSubtreeFocus</h3><p class="docs-markdown-p" translation-result="on">为了方便使用，CDK 还提供了两个指令，可以简单地监控某个元素。<code class="docs-markdown-code">cdkMonitorElementFocus</code> 相当于在 <code class="docs-markdown-code">checkChildren</code> 为 <code class="docs-markdown-code">false</code> 的宿主元素上调用 <code class="docs-markdown-code">monitor</code>。 <code class="docs-markdown-code">cdkMonitorSubtreeFocus</code> 相当于在 <code class="docs-markdown-code">checkChildren</code> 为 <code class="docs-markdown-code">true</code> 的宿主元素上调用 <code class="docs-markdown-code">monitor</code>。这两个指令都有一个 <code class="docs-markdown-code">@Output()</code> <code class="docs-markdown-code">cdkFocusChange</code>，每当它发生变化时都会通过该事件发出新的 <code class="docs-markdown-code">FocusOrigin</code>。</p><p class="docs-markdown-p" translation-origin="off">For convenience, the CDK also provides two directives that allow for easily monitoring an element. <code class="docs-markdown-code">cdkMonitorElementFocus</code> is the equivalent of calling <code class="docs-markdown-code">monitor</code> on the host element with <code class="docs-markdown-code">checkChildren</code> set to <code class="docs-markdown-code">false</code>. <code class="docs-markdown-code">cdkMonitorSubtreeFocus</code> is the equivalent of calling <code class="docs-markdown-code">monitor</code> on the host element with <code class="docs-markdown-code">checkChildren</code> set to <code class="docs-markdown-code">true</code>. Each of these directives has an <code class="docs-markdown-code">@Output()</code> <code class="docs-markdown-code">cdkFocusChange</code> that will emit the new <code class="docs-markdown-code">FocusOrigin</code> whenever it changes.</p><div material-docs-example="focus-monitor-directives"></div><h2 class="docs-markdown-h2" id="styling-utilities" translation-result="on">样式实用工具</h2><h2 class="docs-markdown-h2" translation-origin="off">Styling utilities</h2><p class="docs-markdown-p" translation-result="on">CDK <code class="docs-markdown-code">a11y</code> 包中附带了一组 CSS 样式，可用于构建无障碍组件。要使用它们，你必须在全局样式表中包含这些样式。如果你正在和 CDK 一起使用 Material，那么就已经包含这些样式了。</p><p class="docs-markdown-p" translation-origin="off">The CDK <code class="docs-markdown-code">a11y</code> package comes with a set of CSS styles that can be used when building accessible components. To take advantage of them, you have to include the styles in your global stylesheet. If you're using Material together with the CDK, these styles have been included for you already.</p><pre class="docs-markdown-pre"><code class="lang-scss docs-markdown-code">@<span class="hljs-keyword">import</span> <span class="hljs-string">'~@angular/cdk/text-field/text-field'</span>;

@<span class="hljs-keyword">include</span> cdk-a11y();
</code></pre><h3 id="hiding-elements-while-keeping-them-available-for-screen-readers" class="docs-header-link docs-markdown-h3" translation-result="on"><span header-link="-"></span> 隐藏元素，同时保持屏幕阅读器的可用性</h3><h3 class="docs-header-link docs-markdown-h3" translation-origin="off"><span header-link="hiding-elements-while-keeping-them-available-for-screen-readers"></span> Hiding elements, while keeping them available for screen readers</h3><p class="docs-markdown-p" translation-result="on">屏幕阅读器和其它辅助技术在默认情况下都会跳过那些有 <code class="docs-markdown-code">display: none</code>，<code class="docs-markdown-code">visibility: hidden</code> 等样式的元素。在某些情况下，你可能需要从视觉上隐藏一个元素，但同时让它可用于辅助技术。你可以用 <code class="docs-markdown-code">cdk-visually-hidden</code> 类来做到这一点：</p><p class="docs-markdown-p" translation-origin="off">By default, screen readers and other assistive technology will skip elements that have <code class="docs-markdown-code">display: none</code>, <code class="docs-markdown-code">visibility: hidden</code> etc. In some cases you may need to visually hide an element, while keeping it available for assistive technology. You can do so using the <code class="docs-markdown-code">cdk-visually-hidden</code> class:</p><pre class="docs-markdown-pre"><code class="lang-html docs-markdown-code"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"custom-checkbox"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"cdk-visually-hidden"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre><h3 id="targeting-high-contrast-users" class="docs-header-link docs-markdown-h3" translation-result="on"><span header-link="-"></span> 针对高对比度用户</h3><h3 class="docs-header-link docs-markdown-h3" translation-origin="off"><span header-link="targeting-high-contrast-users"></span> Targeting high contrast users</h3><p class="docs-markdown-p" translation-result="on">这个 <code class="docs-markdown-code">a11y</code> 包中提供了一个 mixin，它允许你通过媒体查询来定位那些打开了 Windows 高对比度模式的用户。为了支持这些高对比度用户，你可以用 <code class="docs-markdown-code">cdk-high-contrast</code> mixin 来包装你的样式：</p><p class="docs-markdown-p" translation-origin="off">The <code class="docs-markdown-code">a11y</code> package offers a mixin that allows you to target users that have the Windows high contrast mode turned on, via a media query. To target high contrast users, you can wrap your styles with the <code class="docs-markdown-code">cdk-high-contrast</code> mixin:</p><pre class="docs-markdown-pre"><code class="lang-scss docs-markdown-code"><span class="hljs-selector-tag">button</span> {
  @<span class="hljs-keyword">include</span> cdk-high-contrast {
    <span class="hljs-attribute">outline</span>: solid <span class="hljs-number">1px</span>;
  }
}
</code></pre></div></body></html>