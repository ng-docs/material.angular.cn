<html><head></head><body><div class="docs-markdown"><p class="docs-markdown-p" translation-result="on">Angular Material 提供了两组组件，用以给主要内容添加一些可折叠的附属内容（通常是导航，但也可以是任何内容）。它们就是侧边栏（sidenav）和抽屉（drawer）组件。</p><p class="docs-markdown-p" translation-origin="off">Angular Material provides two sets of components designed to add collapsible side content (often navigation, though it can be any content) alongside some primary content. These are the sidenav and drawer components.</p><p class="docs-markdown-p" translation-result="on">侧边栏组件旨在为全屏应用添加附属内容。要建立侧边栏，我们需要用到三个组件：<code class="docs-markdown-code">&lt;mat-sidenav-container&gt;</code> 用来为主要内容和侧边栏提供一个结构容器；<code class="docs-markdown-code">&lt;mat-sidenav-content&gt;</code> 用来表示主要内容，而 <code class="docs-markdown-code">&lt;mat-sidenav&gt;</code> 用于表示附属内容。</p><p class="docs-markdown-p" translation-origin="off">The sidenav components are designed to add side content to a fullscreen app. To set up a sidenav we use three components: <code class="docs-markdown-code">&lt;mat-sidenav-container&gt;</code> which acts as a structural container for our content and sidenav, <code class="docs-markdown-code">&lt;mat-sidenav-content&gt;</code> which represents the main content, and <code class="docs-markdown-code">&lt;mat-sidenav&gt;</code> which represents the added side content.</p><div material-docs-example="sidenav-overview"></div><p class="docs-markdown-p" translation-result="on">抽屉组件旨在给应用中的一小部分添加附属内容。这可以使用 <code class="docs-markdown-code">&lt;mat-drawer-container&gt;</code>、<code class="docs-markdown-code">&lt;mat-drawer-content&gt;</code> 和 <code class="docs-markdown-code">&lt;mat-drawer&gt;</code> 来实现，它们分别是各个侧边栏组件的等价物。侧边栏会把应用的附属内容作为整体添加进来，而抽屉只在为应用中的一小部分添加附属内容。 它们所支持的大部分特性都一样，但抽屉不支持固定定位方式。</p><p class="docs-markdown-p" translation-origin="off">The drawer component is designed to add side content to a small section of your app. This is accomplished using the <code class="docs-markdown-code">&lt;mat-drawer-container&gt;</code>, <code class="docs-markdown-code">&lt;mat-drawer-content&gt;</code>, and <code class="docs-markdown-code">&lt;mat-drawer&gt;</code> components, which are analogous to their sidenav equivalents. Rather than adding side content to the app as a whole, these are designed to add side content to a small section of your app. They support almost all of the same features, but do not support fixed positioning.</p><div material-docs-example="sidenav-drawer-overview"></div><h3 id="specifying-the-main-and-side-content" class="docs-header-link docs-markdown-h3" translation-result="on"><span header-link="-"></span> 指定主内容和附属内容</h3><h3 class="docs-header-link docs-markdown-h3" translation-origin="off"><span header-link="specifying-the-main-and-side-content"></span> Specifying the main and side content</h3><p class="docs-markdown-p" translation-result="on">无论主内容还是附属内容，都应该放在 <code class="docs-markdown-code">&lt;mat-sidenav-container&gt;</code> 的内部，而那些你不希望被侧边栏影响到的内容（比如头或脚），可以放在该容器的外部。</p><p class="docs-markdown-p" translation-origin="off">Both the main and side content should be placed inside of the <code class="docs-markdown-code">&lt;mat-sidenav-container&gt;</code>, content that you don't want to be affected by the sidenav, such as a header or footer, can be placed outside of the container.</p><p class="docs-markdown-p" translation-result="on">附属内容应该包装在 <code class="docs-markdown-code">&lt;mat-sidenav&gt;</code> 元素中。它的 <code class="docs-markdown-code">position</code> 属性可以指定主内容该放在附属内容的哪一端，它可以是 <code class="docs-markdown-code">start</code> 或 <code class="docs-markdown-code">end</code>，在从左到右书写的语言中下，分别表示把主内容放在附属内容的左侧或右侧。 如果没有指定 <code class="docs-markdown-code">position</code>，则其默认值是 <code class="docs-markdown-code">start</code>。 <code class="docs-markdown-code">&lt;mat-sidenav-container&gt;</code> 最多可以拥有两个 <code class="docs-markdown-code">&lt;mat-sidenav&gt;</code> 元素，但每一侧只能有一个。 <code class="docs-markdown-code">&lt;mat-sidenav&gt;</code> 必须作为 <code class="docs-markdown-code">&lt;mat-sidenav-container&gt;</code> 的直属子节点出现。</p><p class="docs-markdown-p" translation-origin="off">The side content should be wrapped in a <code class="docs-markdown-code">&lt;mat-sidenav&gt;</code> element. The <code class="docs-markdown-code">position</code> property can be used to specify which end of the main content to place the side content on. <code class="docs-markdown-code">position</code> can be either <code class="docs-markdown-code">start</code> or <code class="docs-markdown-code">end</code> which places the side content on the left or right respectively in left-to-right languages. If the <code class="docs-markdown-code">position</code> is not set, the default value of <code class="docs-markdown-code">start</code> will be assumed. A <code class="docs-markdown-code">&lt;mat-sidenav-container&gt;</code> can have up to two <code class="docs-markdown-code">&lt;mat-sidenav&gt;</code> elements total, but only one for any given side. The <code class="docs-markdown-code">&lt;mat-sidenav&gt;</code> must be placed as an immediate child of the <code class="docs-markdown-code">&lt;mat-sidenav-container&gt;</code>.</p><p class="docs-markdown-p" translation-result="on">主要内容应该包裹在 <code class="docs-markdown-code">&lt;mat-sidenav-content&gt;</code> 中，如果没有为 <code class="docs-markdown-code">&lt;mat-sidenav-container&gt;</code> 指定 <code class="docs-markdown-code">&lt;mat-sidenav-content&gt;</code>，则会隐式创建一个，并把 <code class="docs-markdown-code">&lt;mat-sidenav-container&gt;</code> 中除了 <code class="docs-markdown-code">&lt;mat-sidenav&gt;</code> 元素之外的内容都放进去。</p><p class="docs-markdown-p" translation-origin="off">The main content should be wrapped in a <code class="docs-markdown-code">&lt;mat-sidenav-content&gt;</code>. If no <code class="docs-markdown-code">&lt;mat-sidenav-content&gt;</code> is specified for a <code class="docs-markdown-code">&lt;mat-sidenav-container&gt;</code>, one will be created implicitly and all of the content inside the <code class="docs-markdown-code">&lt;mat-sidenav-container&gt;</code> other than the <code class="docs-markdown-code">&lt;mat-sidenav&gt;</code> elements will be placed inside of it.</p><div material-docs-example="sidenav-position"></div><p class="docs-markdown-p" translation-result="on">下面是正确使用侧边栏布局的例子：</p><p class="docs-markdown-p" translation-origin="off">The following are examples of valid sidenav layouts:</p><pre class="docs-markdown-pre"><code class="lang-html docs-markdown-code"><span class="hljs-comment">&lt;!-- Creates a layout with a left-positioned sidenav and explicit content. --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mat-sidenav-container</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">mat-sidenav</span>&gt;</span>Start<span class="hljs-tag">&lt;/<span class="hljs-name">mat-sidenav</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">mat-sidenav-content</span>&gt;</span>Main<span class="hljs-tag">&lt;/<span class="hljs-name">mat-sidenav-content</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mat-sidenav-container</span>&gt;</span>
</code></pre><pre class="docs-markdown-pre"><code class="lang-html docs-markdown-code"><span class="hljs-comment">&lt;!-- Creates a layout with a left and right sidenav and implicit content. --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mat-sidenav-container</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">mat-sidenav</span>&gt;</span>Start<span class="hljs-tag">&lt;/<span class="hljs-name">mat-sidenav</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">mat-sidenav</span> <span class="hljs-attr">position</span>=<span class="hljs-string">"end"</span>&gt;</span>End<span class="hljs-tag">&lt;/<span class="hljs-name">mat-sidenav</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span>Main<span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mat-sidenav-container</span>&gt;</span>
</code></pre><pre class="docs-markdown-pre"><code class="lang-html docs-markdown-code"><span class="hljs-comment">&lt;!-- Creates an empty sidenav container with no sidenavs and implicit empty content. --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mat-sidenav-container</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mat-sidenav-container</span>&gt;</span>
</code></pre><p class="docs-markdown-p" translation-result="on">下面是错误使用侧边栏布局的例子：</p><p class="docs-markdown-p" translation-origin="off">And these are examples of invalid sidenav layouts:</p><pre class="docs-markdown-pre"><code class="lang-html docs-markdown-code"><span class="hljs-comment">&lt;!-- Invalid because there are two `start` position sidenavs. --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mat-sidenav-container</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">mat-sidenav</span>&gt;</span>Start<span class="hljs-tag">&lt;/<span class="hljs-name">mat-sidenav</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">mat-sidenav</span> <span class="hljs-attr">position</span>=<span class="hljs-string">"start"</span>&gt;</span>Start 2<span class="hljs-tag">&lt;/<span class="hljs-name">mat-sidenav</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mat-sidenav-container</span>&gt;</span>
</code></pre><pre class="docs-markdown-pre"><code class="lang-html docs-markdown-code"><span class="hljs-comment">&lt;!-- Invalid because there are multiple `&lt;mat-sidenav-content&gt;` elements. --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mat-sidenav-container</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">mat-sidenav-content</span>&gt;</span>Main<span class="hljs-tag">&lt;/<span class="hljs-name">mat-sidenav-content</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">mat-sidenav-content</span>&gt;</span>Main 2<span class="hljs-tag">&lt;/<span class="hljs-name">mat-sidenav-content</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mat-sidenav-container</span>&gt;</span>
</code></pre><pre class="docs-markdown-pre"><code class="lang-html docs-markdown-code"><span class="hljs-comment">&lt;!-- Invalid because the `&lt;mat-sidenav&gt;` is outside of the `&lt;mat-sidenav-container&gt;`. --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mat-sidenav-container</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mat-sidenav-container</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mat-sidenav</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mat-sidenav</span>&gt;</span>
</code></pre><p class="docs-markdown-p" translation-result="on">这些规则也同样适用于抽屉组件。</p><p class="docs-markdown-p" translation-origin="off">These same rules all apply to the drawer components as well.</p><h3 id="opening-and-closing-a-sidenav" class="docs-header-link docs-markdown-h3" translation-result="on"><span header-link="-"></span> 打开和关闭侧边栏</h3><h3 class="docs-header-link docs-markdown-h3" translation-origin="off"><span header-link="opening-and-closing-a-sidenav"></span> Opening and closing a sidenav</h3><p class="docs-markdown-p" translation-result="on"><code class="docs-markdown-code">&lt;mat-sidenav&gt;</code> 可以使用 <code class="docs-markdown-code">open()</code>、<code class="docs-markdown-code">close()</code> 和 <code class="docs-markdown-code">toggle()</code> 方法来打开或关闭。 它们都会返回一个 <code class="docs-markdown-code">Promise&lt;boolean&gt;</code>，当侧边栏打开之后它会解析为 <code class="docs-markdown-code">true</code>，关闭之后解析为 <code class="docs-markdown-code">false</code>。</p><p class="docs-markdown-p" translation-origin="off">A <code class="docs-markdown-code">&lt;mat-sidenav&gt;</code> can be opened or closed using the <code class="docs-markdown-code">open()</code>, <code class="docs-markdown-code">close()</code> and <code class="docs-markdown-code">toggle()</code> methods. Each of these methods returns a <code class="docs-markdown-code">Promise&lt;boolean&gt;</code> that will be resolved with <code class="docs-markdown-code">true</code> when the sidenav finishes opening or <code class="docs-markdown-code">false</code> when it finishes closing.</p><p class="docs-markdown-p" translation-result="on">这些打开状态也可以在模板中使用 <code class="docs-markdown-code">opened</code> 属性进行设置。该属性支持双向绑定。</p><p class="docs-markdown-p" translation-origin="off">The opened state can also be set via a property binding in the template using the <code class="docs-markdown-code">opened</code> property. The property supports 2-way binding.</p><p class="docs-markdown-p" translation-result="on"><code class="docs-markdown-code">&lt;mat-sidenav&gt;</code> 也支持一些输出属性：<code class="docs-markdown-code">(opened)</code> 表示刚刚打开，<code class="docs-markdown-code">(closed)</code> 表示刚刚关闭。</p><p class="docs-markdown-p" translation-origin="off"><code class="docs-markdown-code">&lt;mat-sidenav&gt;</code> also supports output properties for just open and just close events, The <code class="docs-markdown-code">(opened)</code> and <code class="docs-markdown-code">(closed)</code> properties respectively.</p><div material-docs-example="sidenav-open-close"></div><p class="docs-markdown-p" translation-result="on">所有这些属性和方法也同样可用在 <code class="docs-markdown-code">&lt;mat-drawer&gt;</code> 上。</p><p class="docs-markdown-p" translation-origin="off">All of these properties and methods work on <code class="docs-markdown-code">&lt;mat-drawer&gt;</code> as well.</p><h3 id="changing-the-sidenav-39-s-behavior" class="docs-header-link docs-markdown-h3" translation-result="on"><span header-link="-"></span> 修改侧边栏的行为</h3><h3 class="docs-header-link docs-markdown-h3" translation-origin="off"><span header-link="changing-the-sidenav-39-s-behavior"></span> Changing the sidenav's behavior</h3><p class="docs-markdown-p" translation-result="on"><code class="docs-markdown-code">&lt;mat-sidenav&gt;</code> 可以根据其 <code class="docs-markdown-code">mode</code> 属性的值以三种方式之一进行渲染。</p><p class="docs-markdown-p" translation-origin="off">The <code class="docs-markdown-code">&lt;mat-sidenav&gt;</code> can render in one of three different ways based on the <code class="docs-markdown-code">mode</code> property.</p><table class="docs-markdown-table"><thead><tr class="docs-markdown-tr"><th class="docs-markdown-th">模式</th><th class="docs-markdown-th">说明</th></tr></thead><tbody class="docs-markdown-tbody"><tr class="docs-markdown-tr"><td class="docs-markdown-td"><code class="docs-markdown-code">over</code></td><td class="docs-markdown-td"><p translation-result="on">侧边栏浮在主内容上方，并用一个背景遮住主内容</p><p translation-origin="off">Sidenav floats over the primary content, which is covered by a backdrop</p></td></tr><tr class="docs-markdown-tr"><td class="docs-markdown-td"><code class="docs-markdown-code">push</code></td><td class="docs-markdown-td"><p translation-result="on">侧边栏把主内容挤出去，并用一个背景遮住主内容</p><p translation-origin="off">Sidenav pushes the primary content out of its way, also covering it with a backdrop</p></td></tr><tr class="docs-markdown-tr"><td class="docs-markdown-td"><code class="docs-markdown-code">side</code></td><td class="docs-markdown-td"><p translation-result="on">侧边栏和主内容并排显示，并收缩主内容的宽度，给侧边栏腾出空间</p><p translation-origin="off">Sidenav appears side-by-side with the main content, shrinking the main content's width to make space for the sidenav.</p></td></tr></tbody></table><p class="docs-markdown-p" translation-result="on">如果没有指定 <code class="docs-markdown-code">mode</code>，则默认为 <code class="docs-markdown-code">over</code>。</p><p class="docs-markdown-p" translation-origin="off">If no <code class="docs-markdown-code">mode</code> is specified, <code class="docs-markdown-code">over</code> is used by default.</p><div material-docs-example="sidenav-mode"></div><p class="docs-markdown-p" translation-result="on">侧边栏的 <code class="docs-markdown-code">over</code> 和 <code class="docs-markdown-code">push</code> 模式默认会显示一个背景，但 <code class="docs-markdown-code">side</code> 模式不会。这可以通过 <code class="docs-markdown-code">mat-sidenav-container</code> 上的 <code class="docs-markdown-code">hasBackdrop</code> 属性进行设置。显式把 <code class="docs-markdown-code">hasBackdrop</code> 设置为 <code class="docs-markdown-code">true</code> 或 <code class="docs-markdown-code">false</code> 将会为侧边栏改写默认的背景可见性，而不管处在什么模式下。不设置该属性或把它设置为 <code class="docs-markdown-code">null</code> 将会使用每种模式下默认的背景可见性。</p><p class="docs-markdown-p" translation-origin="off">The <code class="docs-markdown-code">over</code> and <code class="docs-markdown-code">push</code> sidenav modes show a backdrop by default, while the <code class="docs-markdown-code">side</code> mode does not. This can be customized by setting the <code class="docs-markdown-code">hasBackdrop</code> property on <code class="docs-markdown-code">mat-sidenav-container</code>. Explicitly setting <code class="docs-markdown-code">hasBackdrop</code> to <code class="docs-markdown-code">true</code> or <code class="docs-markdown-code">false</code> will override the default backdrop visibility setting for all sidenavs regadless of mode. Leaving the property unset or setting it to <code class="docs-markdown-code">null</code> will use the default backdrop visibility for each mode.</p><div material-docs-example="sidenav-backdrop"></div><p class="docs-markdown-p" translation-result="on"><code class="docs-markdown-code">&lt;mat-drawer&gt;</code> 也同样支持这些模式和选项。</p><p class="docs-markdown-p" translation-origin="off"><code class="docs-markdown-code">&lt;mat-drawer&gt;</code> also supports all of these same modes and options.</p><h3 id="disabling-automatic-close" class="docs-header-link docs-markdown-h3" translation-result="on"><span header-link="-"></span> 禁用自动关闭功能</h3><h3 class="docs-header-link docs-markdown-h3" translation-origin="off"><span header-link="disabling-automatic-close"></span> Disabling automatic close</h3><p class="docs-markdown-p" translation-result="on">点击背景或按下 <kbd>Esc</kbd> 键通常会关闭侧边栏。 不过，可以通过设置 <code class="docs-markdown-code">&lt;mat-sidenav&gt;</code> 或 <code class="docs-markdown-code">&lt;mat-drawer&gt;</code> 上的 <code class="docs-markdown-code">disableClose</code> 属性来禁用这种自动关闭的行为。</p><p class="docs-markdown-p" translation-origin="off">Clicking on the backdrop or pressing the <kbd>Esc</kbd> key will normally close an open sidenav. However, this automatic closing behavior can be disabled by setting the <code class="docs-markdown-code">disableClose</code> property on the <code class="docs-markdown-code">&lt;mat-sidenav&gt;</code> or <code class="docs-markdown-code">&lt;mat-drawer&gt;</code> that you want to disable the behavior for.</p><p class="docs-markdown-p" translation-result="on">可以通过给 <code class="docs-markdown-code">&lt;mat-sidenav&gt;</code> 添加 <code class="docs-markdown-code">keydown</code> 监听器来定制 <kbd>Esc</kbd> 处理器。 可以通过 <code class="docs-markdown-code">&lt;mat-sidenav-container&gt;</code> 的输出属性 <code class="docs-markdown-code">(backdropClick)</code> 来定制点击背景的处理器。</p><p class="docs-markdown-p" translation-origin="off">Custom handling for <kbd>Esc</kbd> can be done by adding a keydown listener to the <code class="docs-markdown-code">&lt;mat-sidenav&gt;</code>. Custom handling for backdrop clicks can be done via the <code class="docs-markdown-code">(backdropClick)</code> output property on <code class="docs-markdown-code">&lt;mat-sidenav-container&gt;</code>.</p><div material-docs-example="sidenav-disable-close"></div><h3 id="resizing-an-open-sidenav" class="docs-header-link docs-markdown-h3" translation-result="on"><span header-link="-"></span> 调整打开侧边栏的大小</h3><h3 class="docs-header-link docs-markdown-h3" translation-origin="off"><span header-link="resizing-an-open-sidenav"></span> Resizing an open sidenav</h3><p class="docs-markdown-p" translation-result="on">默认情况下，Material 只会在一些关键时刻（打开、窗口调整大小、模式改变）测量和调整容器的大小，以避免布局颠簸。 但是在某些情况下这可能会有问题。如果你希望在打开抽屉时更改其宽度，可以使用 <code class="docs-markdown-code">autosize</code> 选项来告诉 Material 继续测量它。 注意，使用该选项时应该<strong>风险自担</strong>，因为它可能会导致性能问题。</p><p class="docs-markdown-p" translation-origin="off">By default, Material will only measure and resize the drawer container in a few key moments (on open, on window resize, on mode change) in order to avoid layout thrashing, however there are cases where this can be problematic. If your app requires for a drawer to change its width while it is open, you can use the <code class="docs-markdown-code">autosize</code> option to tell Material to continue measuring it. Note that you should use this option <strong>at your own risk</strong>, because it could cause performance issues.</p><div material-docs-example="sidenav-autosize"></div><h3 id="setting-the-sidenav-39-s-size" class="docs-header-link docs-markdown-h3" translation-result="on"><span header-link="-"></span> 设置侧边栏大小</h3><h3 class="docs-header-link docs-markdown-h3" translation-origin="off"><span header-link="setting-the-sidenav-39-s-size"></span> Setting the sidenav's size</h3><p class="docs-markdown-p" translation-result="on">默认情况下，<code class="docs-markdown-code">&lt;mat-sidenav&gt;</code> 和 <code class="docs-markdown-code">&lt;mat-drawer&gt;</code> 应该自适应其内容的尺寸。不过也可以通过 CSS 来显式指定宽度：</p><p class="docs-markdown-p" translation-origin="off">The <code class="docs-markdown-code">&lt;mat-sidenav&gt;</code> and <code class="docs-markdown-code">&lt;mat-drawer&gt;</code> will, by default, fit the size of its content. The width can be explicitly set via CSS:</p><pre class="docs-markdown-pre"><code class="lang-css docs-markdown-code"><span class="hljs-selector-tag">mat-sidenav</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;
}
</code></pre><p class="docs-markdown-p" translation-result="on">避免使用基于百分比的宽度，因为 <code class="docs-markdown-code">resize</code> 事件尚未支持它。</p><p class="docs-markdown-p" translation-origin="off">Try to avoid percent based width as <code class="docs-markdown-code">resize</code> events are not (yet) supported.</p><h3 id="fixed-position-sidenavs" class="docs-header-link docs-markdown-h3" translation-result="on"><span header-link="-"></span> 固定定位的侧边栏</h3><h3 class="docs-header-link docs-markdown-h3" translation-origin="off"><span header-link="fixed-position-sidenavs"></span> Fixed position sidenavs</h3><p class="docs-markdown-p" translation-result="on"><code class="docs-markdown-code">&lt;mat-sidenav&gt;</code> 只支持固定定位方式（<code class="docs-markdown-code">&lt;mat-drawer&gt;</code> 不限）。它可以通过设置 <code class="docs-markdown-code">fixedInViewport</code> 属性进行启用。 另外，还可以通过 <code class="docs-markdown-code">fixedTopGap</code> 和 <code class="docs-markdown-code">fixedBottomGap</code> 来设置顶部和底部的空白。这些属性可以接受一个像素值来指定要加到顶部或底部的空白尺寸。</p><p class="docs-markdown-p" translation-origin="off">For <code class="docs-markdown-code">&lt;mat-sidenav&gt;</code> only (not <code class="docs-markdown-code">&lt;mat-drawer&gt;</code>) fixed positioning is supported. It can be enabled by setting the <code class="docs-markdown-code">fixedInViewport</code> property. Additionally, top and bottom space can be set via the <code class="docs-markdown-code">fixedTopGap</code> and <code class="docs-markdown-code">fixedBottomGap</code>. These properties accept a pixel value amount of space to add at the top or bottom.</p><div material-docs-example="sidenav-fixed"></div><h3 id="creating-a-responsive-layout-for-mobile-amp-desktop" class="docs-header-link docs-markdown-h3" translation-result="on"><span header-link="-"></span> 为移动端和桌面创建响应式布局</h3><h3 class="docs-header-link docs-markdown-h3" translation-origin="off"><span header-link="creating-a-responsive-layout-for-mobile-amp-desktop"></span> Creating a responsive layout for mobile &amp; desktop</h3><p class="docs-markdown-p" translation-result="on">侧边栏通常要在移动端和桌面端提供不同的行为。在桌面端，只允许内容区滚动是合理的；在移动端，你通常会希望滚动整个 <code class="docs-markdown-code">body</code>，这样就能让浏览器自动隐藏地址栏。侧边栏可以使用 CSS 来设置样式，以针对不同类型的设备进行调整。</p><p class="docs-markdown-p" translation-origin="off">A sidenav often needs to behave differently on a mobile vs a desktop display. On a desktop, it may make sense to have just the content section scroll. However, on mobile you often want the body to be the element that scrolls; this allows the address bar to auto-hide. The sidenav can be styled with CSS to adjust to either type of device.</p><div material-docs-example="sidenav-responsive"></div><h3 id="reacting-to-scroll-events-inside-the-sidenav-container" class="docs-header-link docs-markdown-h3" translation-result="on"><span header-link="-"></span> 响应侧边栏内部的滚动事件</h3><h3 class="docs-header-link docs-markdown-h3" translation-origin="off"><span header-link="reacting-to-scroll-events-inside-the-sidenav-container"></span> Reacting to scroll events inside the sidenav container</h3><p class="docs-markdown-p" translation-result="on">要响应 <code class="docs-markdown-code">&lt;mat-sidenav-container&gt;</code> 内部的滚动事件，你可以通过 <code class="docs-markdown-code">MatSidenavContainer</code> 来获取一个底层的 <code class="docs-markdown-code">CdkScrollable</code> 实例。</p><p class="docs-markdown-p" translation-origin="off">To react to scrolling inside the <code class="docs-markdown-code">&lt;mat-sidenav-container&gt;</code>, you can get a hold of the underlying <code class="docs-markdown-code">CdkScrollable</code> instance through the <code class="docs-markdown-code">MatSidenavContainer</code>.</p><pre class="docs-markdown-pre"><code class="lang-ts docs-markdown-code"><span class="hljs-keyword">class</span> YourComponent <span class="hljs-keyword">implements</span> AfterViewInit {
  <span class="hljs-meta">@ViewChild</span>(MatSidenavContainer) sidenavContainer: MatSidenavContainer;

  ngAfterViewInit() {
    <span class="hljs-keyword">this</span>.sidenavContainer.scrollable.elementScrolled().subscribe(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-comment">/* react to scrolling */</span>);
  }
}
</code></pre><h3 id="accessibility" class="docs-header-link docs-markdown-h3" translation-result="on"><span header-link="-"></span> 无障碍性</h3><h3 class="docs-header-link docs-markdown-h3" translation-origin="off"><span header-link="accessibility"></span> Accessibility</h3><p class="docs-markdown-p" translation-result="on"><code class="docs-markdown-code">&lt;mat-sidenav&gt;</code> 和 <code class="docs-markdown-code">&lt;mat-sidenav-content&gt;</code> 都应该根据它们的上下文给出一个合适的 <code class="docs-markdown-code">role</code> 属性。</p><p class="docs-markdown-p" translation-origin="off">The <code class="docs-markdown-code">&lt;mat-sidenav&gt;</code> an <code class="docs-markdown-code">&lt;mat-sidenav-content&gt;</code> should each be given an appropriate <code class="docs-markdown-code">role</code> attribute depending on the context in which they are used.</p><p class="docs-markdown-p" translation-result="on">比如，包含到其它页面的链接的 <code class="docs-markdown-code">&lt;mat-sidenav&gt;</code> 可以标记为 <code class="docs-markdown-code">role="navigation"</code>，而包含目录的则应该标记为 <code class="docs-markdown-code">role="directory"</code>。 如果没有什么特别的角色来描述这个侧边栏，建议使用 <code class="docs-markdown-code">role="region"</code>。</p><p class="docs-markdown-p" translation-origin="off">For example, a <code class="docs-markdown-code">&lt;mat-sidenav&gt;</code> that contains links to other pages might be marked <code class="docs-markdown-code">role="navigation"</code>, whereas one that contains a table of contents about might be marked as <code class="docs-markdown-code">role="directory"</code>. If there is no more specific role that describes your sidenav, <code class="docs-markdown-code">role="region"</code> is recommended.</p><p class="docs-markdown-p" translation-result="on">同样，<code class="docs-markdown-code">&lt;mat-sidenav-content&gt;</code> 也应该基于其包含的内容来指定角色。如果它表示页面的主要内容，就应该标记为 <code class="docs-markdown-code">role="main"</code>。 如果没办法指定合理的角色，同样可以用 <code class="docs-markdown-code">role="region"</code> 作为回退值。</p><p class="docs-markdown-p" translation-origin="off">Similarly, the <code class="docs-markdown-code">&lt;mat-sidenav-content&gt;</code> should be given a role based on what it contains. If it represents the primary content of the page, it may make sense to mark it <code class="docs-markdown-code">role="main"</code>. If no more specific role makes sense, <code class="docs-markdown-code">role="region"</code> is again a good fallback.</p><h3 id="troubleshooting" class="docs-header-link docs-markdown-h3" translation-result="on"><span header-link="-"></span> 排查问题</h3><h3 class="docs-header-link docs-markdown-h3" translation-origin="off"><span header-link="troubleshooting"></span> Troubleshooting</h3><h4 id="error-a-drawer-was-already-declared-for-39-position-quot-quot-39-" class="docs-header-link docs-markdown-h4" translation-result="on"><span header-link="error-a-drawer-was-already-declared-for-39-position-quot-quot-39-br-39-position-quot-quot-39-"></span> Error: A drawer was already declared for 'position="..."'<br>（指定的 'position="..."' 处已经声明了一个抽屉）</h4><h4 class="docs-header-link docs-markdown-h4" translation-origin="off"><span header-link="error-a-drawer-was-already-declared-for-39-position-quot-quot-39-"></span> Error: A drawer was already declared for 'position="..."'</h4><p class="docs-markdown-p" translation-result="on">如果在指定容器的同一个 <code class="docs-markdown-code">position</code> 有多个侧边栏或抽屉，就会抛出本错误。 由于 <code class="docs-markdown-code">position</code> 属性默认为 <code class="docs-markdown-code">start</code>，所以出现该问题可能只是因为你忘了给 <code class="docs-markdown-code">end</code> 侧边栏标记上 <code class="docs-markdown-code">position="end"</code>。</p><p class="docs-markdown-p" translation-origin="off">This error is thrown if you have more than one sidenav or drawer in a given container with the same <code class="docs-markdown-code">position</code>. The <code class="docs-markdown-code">position</code> property defaults to <code class="docs-markdown-code">start</code>, so the issue may just be that you forgot to mark the <code class="docs-markdown-code">end</code> sidenav with <code class="docs-markdown-code">position="end"</code>.</p></div></body></html>