<html><head></head><body><div class="docs-markdown"><p class="docs-markdown-p" translation-result="on">这个 <code class="docs-markdown-code">scrolling</code> 包为那些要对滚动事件做出反应的指令提供了辅助设施。</p><p class="docs-markdown-p" translation-origin="off">The <code class="docs-markdown-code">scrolling</code> package provides helpers for directives that react to scroll events.</p><h3 id="cdkscrollable-and-scrolldispatcher" class="docs-header-link docs-markdown-h3" translation-result="on"><span header-link="cdkscrollable-scrolldispatcher-"></span> cdkScrollable（可滚动的） 和 ScrollDispatcher（滚动派发器）</h3><h3 class="docs-header-link docs-markdown-h3" translation-origin="off"><span header-link="cdkscrollable-and-scrolldispatcher"></span> cdkScrollable and ScrollDispatcher</h3><p class="docs-markdown-p" translation-result="on"><code class="docs-markdown-code">cdkScrollable</code> 指令和 <code class="docs-markdown-code">ScrollDispatcher</code> 服务一起让组件能对其任意上级滚动容器中的滚动事件做出反应。</p><p class="docs-markdown-p" translation-origin="off">The <code class="docs-markdown-code">cdkScrollable</code> directive and the <code class="docs-markdown-code">ScrollDispatcher</code> service together allow components to react to scrolling in any of its ancestor scrolling containers.</p><p class="docs-markdown-p" translation-result="on">要把 <code class="docs-markdown-code">cdkScrollable</code> 指令应用在任何充当滚动容器的元素上。这会把该元素标记为 <code class="docs-markdown-code">Scrollable</code> 并把它注册到 <code class="docs-markdown-code">ScrollDispatcher</code> 中。这时派发器允许组件分享这些事件监听器和应用中所有可滚动容器的知识。</p><p class="docs-markdown-p" translation-origin="off">The <code class="docs-markdown-code">cdkScrollable</code> directive should be applied to any element that acts as a scrolling container. This marks the element as a <code class="docs-markdown-code">Scrollable</code> and registers it with the <code class="docs-markdown-code">ScrollDispatcher</code>. The dispatcher, then, allows components to share both event listeners and knowledge of all of the scrollable containers in the application.</p><h3 id="viewportruler" class="docs-header-link docs-markdown-h3"><span header-link="viewportruler"></span> ViewportRuler</h3><p class="docs-markdown-p" translation-result="on"><code class="docs-markdown-code">ViewportRuler</code>是一种可注入的服务，用于衡量浏览器视口的范围。</p><p class="docs-markdown-p" translation-origin="off">The <code class="docs-markdown-code">ViewportRuler</code> is a service that can be injected and used to measure the bounds of the browser viewport.</p><h3 id="virtual-scrolling" class="docs-header-link docs-markdown-h3" translation-result="on"><span header-link="-"></span> 虚拟滚动</h3><h3 class="docs-header-link docs-markdown-h3" translation-origin="off"><span header-link="virtual-scrolling"></span> Virtual scrolling</h3><p class="docs-markdown-p" translation-result="on"><code class="docs-markdown-code">&lt;cdk-virtual-scroll-viewport&gt;</code> 通过仅仅渲染那些屏幕上可见的条目，来高效的显示大型列表。在任何浏览器中加载数百个元素都会很慢，虚拟滚动可以用一种高效的方式模拟渲染全部条目，方法是让容器元素的高度与要渲染的元素的总高度相同，然后才渲染视图中的条目。虚拟滚动不同于无限滚动这样的策略，它会渲染一定数量的元素，然后在你点击两端时渲染剩下的元素。</p><p class="docs-markdown-p" translation-origin="off">The <code class="docs-markdown-code">&lt;cdk-virtual-scroll-viewport&gt;</code> displays large lists of elements performantly by only rendering the items that fit on-screen. Loading hundreds of elements can be slow in any browser; virtual scrolling enables a performant way to simulate all items being rendered by making the height of the container element the same as the height of total number of elements to be rendered, and then only rendering the items in view. Virtual scrolling is different from strategies like infinite scroll where it renders a set amount of elements and then when you hit the end renders the rest.</p><h4 id="creating-items-in-the-viewport" class="docs-header-link docs-markdown-h4" translation-result="on"><span header-link="-"></span> 在视口中创建条目</h4><h4 class="docs-header-link docs-markdown-h4" translation-origin="off"><span header-link="creating-items-in-the-viewport"></span> Creating items in the viewport</h4><p class="docs-markdown-p" translation-result="on"><code class="docs-markdown-code">*cdkVirtualFor</code> 替换了 <code class="docs-markdown-code">&lt;cdk-virtual-scroll-viewport&gt;</code> 中的 <a href="https://angular.io/api/common/NgForOf" class="docs-markdown-a"><code class="docs-markdown-code">*ngFor</code></a>，它支持与 <a href="https://angular.io/api/common/NgForOf" class="docs-markdown-a"><code class="docs-markdown-code">*ngFor</code></a> 完全相同的API。最简单的用法就是指定条目列表（注意，必须在视口中设置 <code class="docs-markdown-code">itemSize</code> 属性）：</p><p class="docs-markdown-p" translation-origin="off"><code class="docs-markdown-code">*cdkVirtualFor</code> replaces <code class="docs-markdown-code">*ngFor</code> inside of a <code class="docs-markdown-code">&lt;cdk-virtual-scroll-viewport&gt;</code>, supporting the exact same API as <a href="https://angular.io/api/common/NgForOf" class="docs-markdown-a"><code class="docs-markdown-code">*ngFor</code></a>. The simplest usage just specifies the list of items (note that the <code class="docs-markdown-code">itemSize</code> property on the viewport must be set):</p><div material-docs-example="cdk-virtual-scroll-overview"></div><p class="docs-markdown-p" translation-result="on"><code class="docs-markdown-code">*cdkVirtualFor</code> 让模板中可以使用这些上下文变量：</p><p class="docs-markdown-p" translation-origin="off"><code class="docs-markdown-code">*cdkVirtualFor</code> makes the following context variables available to the template:</p><table class="docs-markdown-table"><thead><tr class="docs-markdown-tr"><th class="docs-markdown-th"><p translation-result="on">上下文变量</p><p translation-origin="off">Context variable</p></th><th class="docs-markdown-th"><p translation-result="on">说明</p><p translation-origin="off">Description</p></th></tr></thead><tbody class="docs-markdown-tbody"><tr class="docs-markdown-tr"><td class="docs-markdown-td"><code class="docs-markdown-code">index</code></td><td class="docs-markdown-td"><p translation-result="on">该条目在数据源中的索引。</p><p translation-origin="off">The index of the item in the data source.</p></td></tr><tr class="docs-markdown-tr"><td class="docs-markdown-td"><code class="docs-markdown-code">count</code></td><td class="docs-markdown-td"><p translation-result="on">数据源中的条目总数。</p><p translation-origin="off">The total number of items in the data source.</p></td></tr><tr class="docs-markdown-tr"><td class="docs-markdown-td"><code class="docs-markdown-code">first</code></td><td class="docs-markdown-td"><p translation-result="on">这是否是数据源中的第一个条目。</p><p translation-origin="off">Whether this is the first item in the data source.</p></td></tr><tr class="docs-markdown-tr"><td class="docs-markdown-td"><code class="docs-markdown-code">last</code></td><td class="docs-markdown-td"><p translation-result="on">这是否是数据源中的最后一个条目。</p><p translation-origin="off">Whether this is the last item in the data source.</p></td></tr><tr class="docs-markdown-tr"><td class="docs-markdown-td"><code class="docs-markdown-code">even</code></td><td class="docs-markdown-td"><p translation-result="on">该 <code class="docs-markdown-code">index</code> 是否为偶数。</p><p translation-origin="off">Whether the <code class="docs-markdown-code">index</code> is even.</p></td></tr><tr class="docs-markdown-tr"><td class="docs-markdown-td"><code class="docs-markdown-code">odd</code></td><td class="docs-markdown-td"><p translation-result="on">该 <code class="docs-markdown-code">index</code> 是否为奇数。</p><p translation-origin="off">Whether the <code class="docs-markdown-code">index</code> is odd.</p></td></tr></tbody></table><p class="docs-markdown-p" translation-result="on">所有这些都是本条目在数据源中的索引，而不是在要渲染的那部分数据的索引。</p><p class="docs-markdown-p" translation-origin="off">All of these apply to the index of the item in the data source, not the index in the rendered portion of the data.</p><div material-docs-example="cdk-virtual-scroll-context"></div><p class="docs-markdown-p" translation-result="on">像 <code class="docs-markdown-code">*ngFor</code> 的 <code class="docs-markdown-code">trackBy</code> 一样，这里也可以指定 <code class="docs-markdown-code">trackBy</code> 函数，工作方式也都一样。传给这个 <code class="docs-markdown-code">trackBy</code> 的 <code class="docs-markdown-code">index</code> 是在数据源中的索引，而不是在要渲染的这部分数据中的索引。</p><p class="docs-markdown-p" translation-origin="off">A <code class="docs-markdown-code">trackBy</code> function can be specified and works the same as the <code class="docs-markdown-code">*ngFor</code> <code class="docs-markdown-code">trackBy</code>. The <code class="docs-markdown-code">index</code> passed to the tracking function will be the index in the data source, not the index in the rendered portion.</p><h5 class="docs-markdown-h5" id="view-recycling" translation-result="on">视图回收</h5><h5 class="docs-markdown-h5" translation-origin="off">View recycling</h5><p class="docs-markdown-p" translation-result="on">为了提高渲染性能， <code class="docs-markdown-code">*cdkVirtualFor</code> 会缓存那些曾经创建过但不再需要的视图。当要创建一个新视图时，会转而复用一个已缓存的视图。可以通过 <code class="docs-markdown-code">templateCacheSize</code> 属性来调整视图缓存的大小。把这个大小设置为 <code class="docs-markdown-code">0</code> 会禁用缓存。如果你的模板在内存方面很昂贵，你可能会希望减小这个数字，以免在模板缓存上花费太多内存。</p><p class="docs-markdown-p" translation-origin="off">To improve rendering performance, <code class="docs-markdown-code">*cdkVirtualFor</code> caches previously created views after they are no longer needed. When a new view would normally be created, a cached view is reused instead. The size of the view cache can be adjusted via the <code class="docs-markdown-code">templateCacheSize</code> property; setting this size to <code class="docs-markdown-code">0</code> disables caching. If your templates are expensive in terms of memory you may wish to reduce this number to avoid spending too much memory on the template cache.</p><div material-docs-example="cdk-virtual-scroll-template-cache"></div><h5 class="docs-markdown-h5" id="specifying-data" translation-result="on">指定数据</h5><h5 class="docs-markdown-h5" translation-origin="off">Specifying data</h5><p class="docs-markdown-p" translation-result="on"><code class="docs-markdown-code">*cdkVirtualFor</code> 接受来自 <code class="docs-markdown-code">Array</code>、<code class="docs-markdown-code">Observable&lt;Array&gt;</code> 或 <code class="docs-markdown-code">DataSource</code> 的数据。虚拟滚动的 <code class="docs-markdown-code">DataSource</code> 与表格和树组件所用的 <code class="docs-markdown-code">DataSource</code> 是同一个。 <code class="docs-markdown-code">DataSource</code> 只是一个抽象类，它有两个方法：<code class="docs-markdown-code">connect</code> 和 <code class="docs-markdown-code">disconnect</code>。虚拟滚动视口将调用这个 <code class="docs-markdown-code">connect</code> 方法，以接收一个流，这个流会发出要渲染的数据数组。当 viewport 被销毁时，视口会调用 <code class="docs-markdown-code">disconnect</code>，这可能是清理连接过程中注册进来的所有订阅的最佳时机。</p><p class="docs-markdown-p" translation-origin="off"><code class="docs-markdown-code">*cdkVirtualFor</code> accepts data from an <code class="docs-markdown-code">Array</code>, <code class="docs-markdown-code">Observable&lt;Array&gt;</code>, or <code class="docs-markdown-code">DataSource</code>. The <code class="docs-markdown-code">DataSource</code> for the virtual scroll is the same one used by the table and tree components. A <code class="docs-markdown-code">DataSource</code> is simply an abstract class that has two methods: <code class="docs-markdown-code">connect</code> and <code class="docs-markdown-code">disconnect</code>. The <code class="docs-markdown-code">connect</code> method will be called by the virtual scroll viewport to receive a stream that emits the data array that should be rendered. The viewport will call <code class="docs-markdown-code">disconnect</code> when the viewport is destroyed, which may be the right time to clean up any subscriptions that were registered during the connect process.</p><div material-docs-example="cdk-virtual-scroll-data-source"></div><h4 id="scrolling-over-fixed-size-items" class="docs-header-link docs-markdown-h4" translation-result="on"><span header-link="-"></span> 滚动那些固定大小的条目</h4><h4 class="docs-header-link docs-markdown-h4" translation-origin="off"><span header-link="scrolling-over-fixed-size-items"></span> Scrolling over fixed size items</h4><p class="docs-markdown-p" translation-result="on">当所有条目都是固定大小时，你可以使用 <code class="docs-markdown-code">FixedSizeVirtualScrollStrategy</code>。可以用 <code class="docs-markdown-code">itemSize</code> 指令轻松地将它添加到视口中。这种约束的优点是它可以提供更好的性能，因为在渲染条目时不需要进行测量。</p><p class="docs-markdown-p" translation-origin="off">When all items are the same fixed size, you can use the <code class="docs-markdown-code">FixedSizeVirtualScrollStrategy</code>. This can be easily added to your viewport using the <code class="docs-markdown-code">itemSize</code> directive. The advantage of this constraint is that it allows for better performance, since items do not need to be measured as they are rendered.</p><p class="docs-markdown-p" translation-result="on">固定大小的策略也支持设置一些缓冲区参数，用来决定渲染多少额外内容，也就是视口可见内容之外的部分。第一个参数是 <code class="docs-markdown-code">minBufferPx</code>。 <code class="docs-markdown-code">minBufferPx</code> 是视口必须渲染的最小内容缓冲区数量（以像素为单位）。如果视口检测到要缓冲的内容小于这个数量（未填满），就会立即渲染更多内容。 第二个参数是 <code class="docs-markdown-code">maxBufferPx</code>。它会告诉视口当检测到需要更多缓冲区的时候要渲染多少个备用缓冲区空间。</p><p class="docs-markdown-p" translation-origin="off">The fixed size strategy also supports setting a couple of buffer parameters that determine how much extra content is rendered beyond what is visible in the viewport. The first of these parameters is <code class="docs-markdown-code">minBufferPx</code>. The <code class="docs-markdown-code">minBufferPx</code> is the minimum amount of content buffer (in pixels) that the viewport must render. If the viewport ever detects that there is less buffered content it will immediately render more. The second buffer parameter is <code class="docs-markdown-code">maxBufferPx</code>. This tells the viewport how much buffer space to render back up to when it detects that more buffer is required.</p><p class="docs-markdown-p" translation-result="on">这两个缓冲区参数的作用可以用一个例子来说明。假设我们有以下参数：<code class="docs-markdown-code">itemSize = 50</code>、<code class="docs-markdown-code">minBufferPx = 100</code>、<code class="docs-markdown-code">maxBufferPx = 250</code>。当用户滚动浏览内容时，视口就会检测到只剩下 <code class="docs-markdown-code">90px</code> 的缓冲区。由于它小于 <code class="docs-markdown-code">minBufferPx</code>，所以视口必须渲染更多缓冲区。它必须渲染足够数量的缓冲区，直到其大于等于 <code class="docs-markdown-code">maxBufferPx</code>。在这种情况下，它渲染了4个条目（额外的 <code class="docs-markdown-code">200px</code>），使缓冲区总大小达到<code class="docs-markdown-code">290px</code>，略高于<code class="docs-markdown-code">maxBufferPx</code> 。</p><p class="docs-markdown-p" translation-origin="off">The interaction of these two buffer parameters can be best illustrated with an example. Supposed that we have the following parameters: <code class="docs-markdown-code">itemSize = 50</code>, <code class="docs-markdown-code">minBufferPx = 100</code>, <code class="docs-markdown-code">maxBufferPx = 250</code>. As the user is scrolling through the content the viewport detects that there is only <code class="docs-markdown-code">90px</code> of buffer remaining. Since this is below <code class="docs-markdown-code">minBufferPx</code> the viewport must render more buffer. It must render at least enough buffer to get back to <code class="docs-markdown-code">maxBufferPx</code>. In this case, it renders 4 items (an additional <code class="docs-markdown-code">200px</code>) to bring the total buffer size to <code class="docs-markdown-code">290px</code>, back above <code class="docs-markdown-code">maxBufferPx</code>.</p><div material-docs-example="cdk-virtual-scroll-fixed-buffer"></div><p class="docs-markdown-p" translation-result="on">其他虚拟滚动策略可以通过扩展 <code class="docs-markdown-code">VirtualScrollStrategy</code> 来实现。目前正在 <code class="docs-markdown-code">@angular/cdk-experimental</code> 开发一种适用于不同大小元素的自动调整策略，但还没有准备好用于生产环境。</p><p class="docs-markdown-p" translation-origin="off">Other virtual scrolling strategies can be implemented by extending <code class="docs-markdown-code">VirtualScrollStrategy</code>. An autosize strategy that works on elements of differing sizes is currently being developed in <code class="docs-markdown-code">@angular/cdk-experimental</code>, but it is not ready for production use yet.</p><h3 id="viewport-orientation" class="docs-header-link docs-markdown-h3" translation-result="on"><span header-link="-"></span> 视口方向</h3><h3 class="docs-header-link docs-markdown-h3" translation-origin="off"><span header-link="viewport-orientation"></span> Viewport orientation</h3><p class="docs-markdown-p" translation-result="on">虚拟滚动视口默认为垂直方向，也可以设置为 <code class="docs-markdown-code">orientation="horizontal"</code>。在改变方向时，要确保该条目是用 CSS 进行水平布局的。要做到这一点，你可能希望把 <code class="docs-markdown-code">.cdk-virtual-scroll-content-wrapper</code> 类作为 CSS 的目标，它是包含待渲染内容的包装元素。</p><p class="docs-markdown-p" translation-origin="off">The virtual-scroll viewport defaults to a vertical orientation, but can also be set to <code class="docs-markdown-code">orientation="horizontal"</code>. When changing the orientation, ensure that the item are laid out horizontally via CSS. To do this you may want to target CSS at <code class="docs-markdown-code">.cdk-virtual-scroll-content-wrapper</code> which is the wrapper element that contains the rendered content.</p><div material-docs-example="cdk-virtual-scroll-horizontal"></div><h3 id="elements-with-parent-tag-requirements" class="docs-header-link docs-markdown-h3" translation-result="on"><span header-link="-"></span> 那些对父标签有特定要求的元素</h3><h3 class="docs-header-link docs-markdown-h3" translation-origin="off"><span header-link="elements-with-parent-tag-requirements"></span> Elements with parent tag requirements</h3><p class="docs-markdown-p" translation-result="on">某些HTML元素（如 <code class="docs-markdown-code">&lt;tr&gt;</code> 和 <code class="docs-markdown-code">&lt;li&gt;</code>）对它们所在的父元素种类有一些限制。要想对这些类型的元素进行虚拟滚动操作，就要把它们放在合适的父元素中，然后把它们共同包装在 <code class="docs-markdown-code">cdk-virtual-scroll-viewport</code> 中。注意，父组件中不要引入额外的空白区（比如通过 <code class="docs-markdown-code">margin</code> 或 <code class="docs-markdown-code">padding</code>），因为这样会干扰滚动。</p><p class="docs-markdown-p" translation-origin="off">Some HTML elements such as <code class="docs-markdown-code">&lt;tr&gt;</code> and <code class="docs-markdown-code">&lt;li&gt;</code> have limitations on the kinds of parent elements they can be placed inside. To enable virtual scrolling over these type of elements, place the elements in their proper parent, and then wrap the whole thing in a <code class="docs-markdown-code">cdk-virtual-scroll-viewport</code>. Be careful that the parent does not introduce additional space (e.g. via <code class="docs-markdown-code">margin</code> or <code class="docs-markdown-code">padding</code>) as it will interfere with the scrolling.</p><div material-docs-example="cdk-virtual-scroll-dl"></div><h3 id="scrolling-strategies" class="docs-header-link docs-markdown-h3" translation-result="on"><span header-link="-"></span> 滚动策略</h3><h3 class="docs-header-link docs-markdown-h3" translation-origin="off"><span header-link="scrolling-strategies"></span> Scrolling strategies</h3><p class="docs-markdown-p" translation-result="on">为了确定整个内容的大小以及它在任何时刻需要实际渲染的内容，视口依赖于所提供的一个 <code class="docs-markdown-code">VirtualScrollStrategy</code>。提供它的最简单方式是在视口上使用 <code class="docs-markdown-code">itemSize</code> 指令（例如 <code class="docs-markdown-code">&lt;cdk-virtual-scroll-viewport itemSize="50"&gt;</code>）。但是，也可以通过创建一个实现 <code class="docs-markdown-code">VirtualScrollStrategy</code> 接口的类来提供自定义策略，并在包含此视口的组件上把它提供为 <code class="docs-markdown-code">VIRTUAL_SCROLL_STRATEGY</code>。</p><p class="docs-markdown-p" translation-origin="off">In order to determine how large the overall content is and what portion of it actually needs to be rendered at any given time the viewport relies on a <code class="docs-markdown-code">VirtualScrollStrategy</code> being provided. The simplest way to provide it is to use the <code class="docs-markdown-code">itemSize</code> directive on the viewport (e.g. <code class="docs-markdown-code">&lt;cdk-virtual-scroll-viewport itemSize="50"&gt;</code>). However it is also possible to provide a custom strategy by creating a class that implements the <code class="docs-markdown-code">VirtualScrollStrategy</code> interface and providing it as the <code class="docs-markdown-code">VIRTUAL_SCROLL_STRATEGY</code> on the component containing your viewport.</p><div material-docs-example="cdk-virtual-scroll-custom-strategy"></div></div></body></html>